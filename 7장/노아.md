# 7장 동시성 렌더링

## 7.1 동기식 렌더링의 문제

동기식 렌더링은 긴 계산 중 UI가 멈추고 입력 반응이 늦어진다. 대량 리스트 필터링, 페이지 전환처럼 비용이 큰 작업이 즉시 DOM에 반영되면서 프레임 드롭과 입력 지연이 발생한다.

동시성 렌더링은 작업을 잘게 나눠 계산하며 중간에 인터럽트가 가능하고, 더 급한 상호작용을 먼저 처리해 화면을 부드럽게 유지한다.

## 7.2 파이버 다시 보기

파이버는 컴포넌트 트리를 "작업 단위"로 세분화한 구조다. 리액트는 현재 트리와 작업중 트리를 더블 버퍼링으로 분리해 계산한 뒤, 준비된 결과만 한 번에 교체한다.

덕분에 렌더 도중 중단·재개가 안전하고, 부분적 완료를 모아 커밋한다. 이 구조가 동시성의 기초가 된다.

## 7.3 업데이트 예약과 지연

업데이트는 생성 시 우선순위가 태깅되고 스케줄러가 "지금 프레임에서 처리할 묶음"을 고른다. 급한 입력(타이핑·클릭 등)은 높은 우선순위로 즉시 렌더하고, 비용 큰 화면 갱신은 뒤로 보내거나 나눠 처리한다.

채팅 예시처럼 수신 메시지는 전환성으로 예약해 UI 상호작용을 방해하지 않게 한다. 이 예약·지연으로 고부하에서도 응답성을 유지한다.

## 7.4 더 깊이 들어가기: 스케줄러

스케줄러는 루트별로 작업을 예약하며 마이크로태스크/매크로태스크 타이밍을 조율한다. 내부적으로 `ensureRootIsScheduled` 같은 루틴으로 활성 레인 집합을 정하고, 더 높은 우선순위 이벤트가 들어오면 진행 중 렌더를 중단해 먼저 처리한다.

가능한 짧은 커밋 단계만 동기적으로 실행하여 메인 스레드 점유를 최소화한다.

## 7.5 렌더 레인

렌더 레인은 업데이트를 우선순위 버킷으로 나누는 비트마스크 기반 메커니즘이다. 스케줄러는 특정 레인들의 집합을 선택해 렌더 단계에 포함하고, 그 결과를 한 번에 커밋한다.

### 대표 레인/우선순위

- **ImmediatePriority / SyncLane**: 급한 입력·동기 이벤트. 즉시 처리
- **UserBlockingPriority**: 입력 후 바로 보여야 하는 반응(버튼 클릭 후 피드백)
- **NormalPriority / DefaultLane**: 일반 UI 갱신
- **TransitionLanes**: 페이지 전환·대규모 필터링처럼 비용 큰 전환성 작업
- **Hydration Lanes**: 서버 렌더링 후 하이드레이션 중 입력/연속 입력 처리
- **RetryLanes**: 실패·지연된 작업 재시도

### 작동 방식

우선순위는 "커밋 직전에 변경을 다시 줄 세우는" 것이 아니라, "이번 렌더에 포함할 업데이트 집합"을 고르는 것이다. 렌더 단계에서 선택된 레인만 계산되고, 커밋은 짧고 중단 없이 해당 결과를 DOM에 적용한다.

여러 레인은 비트마스크로 병합될 수 있고, 서로 얽힌(Entangled) 레인은 일관성을 위해 함께 처리된다.

## 7.6 useTransition

전환성 업데이트를 낮은 우선순위 레인으로 태깅한다. 급한 입력은 끊김 없이 먼저 처리되고, 전환 결과가 준비되면 커밋된다. `isPending`으로 로딩처럼 진행중 상태를 표현해 피드백을 제공한다.

페이지 네비게이션, 대규모 리스트 변환, 데이터 의존 화면 재구성에 적합하다.

```jsx
import { useState, useTransition } from "react";

function SearchApp() {
  const [isPending, startTransition] = useTransition();
  const [inputValue, setInputValue] = useState("");
  const [searchTerm, setSearchTerm] = useState("");

  const handleChange = (e) => {
    // 긴급한 업데이트: 입력창의 값은 즉시 반영
    setInputValue(e.target.value);

    // 긴급하지 않은 업데이트: 검색 결과는 지연 처리
    startTransition(() => {
      setSearchTerm(e.target.value);
    });
  };

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleChange} />
      {isPending ? <div>로딩 중...</div> : <SearchResult term={searchTerm} />}
    </div>
  );
}
```

## 7.7 useDeferredValue

덜 중요한 값 업데이트를 뒤로 미뤄 화면을 매끄럽게 유지한다. 입력 필드는 즉시 반응하지만, 무거운 계산이 필요한 결과 리스트는 이전 값을 잠시 유지하다 새 값이 준비되면 교체한다.

메모화(React.memo, useMemo)와 함께 쓰면 불필요한 리렌더를 줄여 큰 효과를 낸다. 즉시 정확성이 필수인 경고·검증 UI에는 부적합할 수 있다.

```jsx
import { useState, useDeferredValue } from "react";

function SearchApp() {
  const [query, setQuery] = useState("");

  // query 값을 지연시킴
  const deferredQuery = useDeferredValue(query);

  return (
    <div>
      {/* input은 즉시 업데이트되어 사용자 경험이 좋음 */}
      <input
        type="text"
        value={query}
        onChange={(e) => setQuery(e.target.value)}
      />

      {/* SearchList는 지연된 값(deferredQuery)을 사용 */}
      <SearchList query={deferredQuery} />
    </div>
  );
}
```

## 7.8 동시성 렌더링 관련 문제: 티어링

동시성 렌더 동안 외부 상태가 바뀌면 일부 컴포넌트는 새 값, 일부는 옛 값으로 보이는 티어링이 나타난다. 화면이 "찢어진" 듯 보이며, 리스트의 각 항목이 서로 다른 카운트를 표시하는 식의 불일치가 생긴다.

원인은 리액트 내부 state가 아닌 외부 스토어를 비동기 타이밍에 직접 읽을 때 발생한다.

```jsx
// 티어링 문제 예시
let count = 0;
setInterval(() => count++, 1);

const ExpensiveComponent = () => {
  // 외부 변수를 직접 읽어서 티어링 발생 가능
  return <div>{count}</div>;
};
```

### useSyncExternalStore로 일관성 확보

외부 스토어(예: Redux/Zustand, 브라우저 History, WebSocket 이벤트 소스)의 값을 리액트 동시성 모델에 맞게 읽고 구독하는 표준 훅이다.

- **일관된 스냅샷**: 한 번의 렌더에서 읽은 값이 동일하게 유지된다. 렌더 도중 값이 바뀌어도 동일 스냅샷을 사용하고, 다음 렌더에서 최신 값을 읽는다.
- **정확한 구독**: `store.subscribe`로 변경을 등록하고, 해제 타이밍을 리액트가 관리해 메모리 누수·중복 구독을 예방한다.
- **SSR 호환**: `getServerSnapshot`으로 서버 초기값을 제공하면, 하이드레이션 시 값 불일치를 줄인다.

```jsx
import { useSyncExternalStore } from "react";

// 외부 스토어 예시
const store = {
  getSnapshot: () => count,
  subscribe: (callback) => {
    const interval = setInterval(() => callback(), 1000);
    return () => clearInterval(interval);
  },
};

const ExpensiveComponent = () => {
  // useSyncExternalStore로 일관된 값 읽기
  const count = useSyncExternalStore(store.getSnapshot, store.subscribe);
  return <div>{count}</div>;
};
```

## 7.9 렌더링 작업 방식 정리

1. **업데이트 수집**: `setState`·외부 스토어 변경 등으로 생성된 업데이트를 레인에 태깅한다.
2. **렌더 처리**: 선택된 레인 집합에 대해 파이버 트리를 계산해 work-in-progress 트리를 만들고 이전 트리와 diff한다. 렌더는 비동기·인터럽트 가능하다.
3. **커밋 단계**: 준비된 변경을 짧게 동기 적용한다. 커밋은 중단되지 않으며, 이번 렌더에 포함된 레인 결과만 반영된다.
4. **결과 확인/재스케줄**: 남은 낮은 우선순위 레인은 이후 프레임에 렌더·커밋된다. 필요 시 RetryLanes로 재시도한다.

## 7.10 실전 시나리오

### 채팅/실시간 UI

수신 메시지 렌더는 TransitionLanes로 보내 지연·나눠 처리하고, 입력·스크롤은 Immediate/UserBlocking에서 처리해 반응성을 유지한다. 도중에 새 메시지가 와도 타이핑은 끊기지 않는다.

### 대규모 필터링

입력 값은 즉시 반영하되, 필터 결과 리스트는 `useDeferredValue`로 지연해 이전 결과를 잠시 유지한다. `React.memo`로 항목 컴포넌트를 메모화해 재계산을 줄인다.

### 외부 카운터/스토어

여러 컴포넌트가 같은 외부 카운트를 표시할 때 `useSyncExternalStore`로 스냅샷을 읽어 모두 동일 값을 보이게 한다. 값 변경은 해당 레인에서 한 번에 리렌더된다.

## 7.11 돌아보기 핵심

- 파이버가 작업을 쪼개고 더블 버퍼링으로 안전하게 교체한다.
- 스케줄러가 프레임마다 처리할 레인 집합을 선택하고, 더 급한 레인이 오면 인터럽트한다.
- 렌더 레인은 우선순위 버킷으로 업데이트를 분류해 사용자 경험을 보호한다.
- `useTransition`은 전환성 작업을 낮은 우선순위로 보내고, `useDeferredValue`는 덜 중요한 값 업데이트를 미뤄 매끄럽게 유지한다.
- `useSyncExternalStore`는 외부 상태와 동시성 렌더의 일관성을 보장해 티어링을 해결한다.

핵심은 리액트가 "무엇을 언제 렌더에 포함할지"를 우선순위로 제어해, 중요한 상호작용은 즉시, 비용 큰 작업은 준비되는 대로 반영함으로써 전체 UX를 안정적으로 끌어올리는 것이다.
