# 7.1 동기식 렌더링의 문제

메인 스레드를 블로킹해서 사용자 경험이 저하되는 것

동기식 렌더링에는 우선순위라는 개념이 없음. 그렇기 때문에 보이지 않는 탭, 로딩 상태 등 우선순위가 낮은 항목들도 동등한 수준으로 취급하여 렌더링함. 이로 인해 메인 스레드가 블락될 수 있음.

# 7.2 파이버 다시 보기

파이버 재조정자는 동시성 렌더링을 가능케 하는 핵심 메커니즘

작업의 우선순위를 설정하여 중요도에 따라 렌더링 작업을 중지하거나 재개함

# 7.3 업데이트 예약과 지연

파이버 재조정자는 스케줄러와 API를 통해 업데이트를 예약하고 지연하는 기능을 구현함.

스케줄러는 setTimeout, MessageChannel 같은 브라우저 API를 사용하여 작업을 예약, 관리하는 시스템.

# 7.4 더 깊이 들어가기

## 스케줄러

타이밍 관련 유틸리티를 제공하는 독립형 패키지.

파이버 재조정자와는 별개로 동작한다. 재조정자 내에서 스케줄러를 사용한다.

마이크로태스크를 예약해서 메인 스레드의 제어를 관리하고 원활한 실행을 보장한다.

- `function ensureRootIsScheduled(root:FiberRoot):void`
  - 루트에 업데이트가 발생할 때마다 호출되며 두 가지 작업을 수행함
  1. 루트가 스케줄에 포함되도록 보장
  2. 루트 스케줄을 처리할 수 있도록 대기 중인 마이크로태스크가 존재하는지 확인
  - 리액트 루트에 대한 업데이트를 효율적으로 관리하고 예약해서 원활한 렌더링을 보장하는데 중점을 둔 함수

# 7.5 렌더 레인

작업의 렌더링과 우선순위 관리를 효율화한다.

업데이트 종류(사용자 상호작용, 데이터 페치, 백그라운드 작업 등), 컴포넌트의 가시성 같은 요인에 따라 운선순위를 정한다.

- SyncHydrationLane
  - 하이드레이션 도중 사용자가 리액트 앱을 클릭하면 클릭 이벤트가 이 레인으로 들어간다.
- SyncLane
  - 사용자가 리액트 앱을 클릭하면 클릭 이벤트가 이 레인으로 들어간다.
- InputContinuousHydrationLane
  - 하이드레이션 도중 발생하는 호버, 스크롤을 비롯한 연속적인 이벤트가 이 레인으로 들어간다.
- InputContinuousLane
  - InputContinuousHydrationLane가 동일하지만 하이드레이션 이후의 이벤트를 다룬다.
- DefaultLane
  - 모든 네트워크 업데이트, setTimeout 같은 타이머, 우선순위가 파악되지 않은 초기 렌더링이 들어간다.
- TransitionHydraionLane
  - 하이드레이션 도중 startTransition에서 발생하는 모든 트랜지션이 이 레인에 배치된다.
- TransitionLanes
  - 하이드레이션 후 startTransition에서 발생하는 모든 트랜지션이 이 레인에 배치된다.
- RetyLanes
  - Suspense에서 발생하는 모든 재시도가 이 레인에 배치된다.

### 렌더 레인 작동 방식

1. 업데이트 수집: 마지막 렌더링 이후에 예약된 모든 업데이트를 수집해서 우선순위에 따라 각 레인에 할당
2. 레인 처리: 우선 순위가 높은 레인부터 각 레인에 있는 업데이트 처리. 같은 레인의 업데이트는 일괄처리
3. 커밋 단계: 모든 업데이트를 처리한 후, DOM에 적용
4. 반복

# 7.6 useTransition

긴급하지 않은 상태 업데이트를 감싸서 UI의 반응성을 유지시켜주는 역할을 한다.

`startTransition`으로 감싸면 TransitionLanes에 들어가 SyncLane보다 우선순위가 낮아져 업데이트 타이밍을 제어한다.

반환값

- isPending
- startTransition

훅이 아닌 startTransition API도 존재한다.

```jsx
import { useState, useTransition } from "react";

function App() {
  const [isPending, startTransition] = useTransition();
  const [inputValue, setInputValue] = useState("");
  const [searchTerm, setSearchTerm] = useState("");

  const handleChange = (e) => {
    // 1. 긴급한 업데이트: 입력창의 값은 즉시 반영되어야 함
    setInputValue(e.target.value);

    // 2. 긴급하지 않은 업데이트: 검색 결과는 약간 늦게 반영되어도 됨
    startTransition(() => {
      setSearchTerm(e.target.value);
    });
  };

  return (
    <div>
      <input type="text" value={inputValue} onChange={handleChange} />
      {isPending ? <div>로딩 중...</div> : <SearchResult term={searchTerm} />}
    </div>
  );
}
```

# 7.7 useDeferredValue

값의 업데이트를 의도적으로 지연시켜 UI의 반응성을 유지하는데 사용

덜 중요한 업데이트 렌더링을 지연하는 것.

`useTransition`이 상태를 업데이트하는 함수를 감싸는 방식이라면, `useDeferredValue`는 빠르게 변하는 값 자체를 감싸서 작동

useDeferredValue는 이전 값과 새 값 사이에 렌더링이 여러 번 발생하지 않도록 동작한다. 즉, 값이 바뀌어도 UI가 매번 새롭게 리렌더링 되지 않는다.

새 값으로 업데이트될 시점을 제어해 한 번에 새 값으로 업데이트되게 한다.

즉, 사용자가 다섯 글자를 연속으로 입력하면 입력 필드는 다섯 번 업데이트되고, 사용자가 입력을 중지한 다음에야 SearchList가 한 번 렌더링 된다. 첫 글자부터 넷째 글자를 입력할 때까지는 SearchList의 렌더링이 중단된다.

```jsx
import { useState, useDeferredValue } from "react";

// 매우 긴 목록을 렌더링하는 무거운 컴포넌트
function SearchList({ query }) {
  // query 값이 바뀔 때마다 복잡한 필터링 로직이 실행된다고 가정
  return <div>{/* query를 사용해 목록을 표시 */}</div>;
}

function App() {
  const [query, setQuery] = useState("");

  // 1. query 값을 지연시킴
  const deferredQuery = useDeferredValue(query);

  const handleChange = (e) => {
    setQuery(e.target.value);
  };

  return (
    <div>
      {/* 2. input은 즉시 업데이트되어 사용자 경험이 좋음 */}
      <input type="text" value={query} onChange={handleChange} />

      {/* 3. SearchList는 지연된 값(deferredQuery)을 사용 */}
      {/* 이 컴포넌트는 사용자의 타이핑을 방해하지 않고 나중에 렌더링됨 */}
      <SearchList query={deferredQuery} />
    </div>
  );
}
```

사용 시기

- 대규모 데이터를 검색하거나 필터링할 때
- 복잡한 시각화나 애니메이션을 렌더링할 때
- 백그라운드에서 서버의 데이터를 업데이트할 때
- 사용자 상호 작용에 영향을 미칠 수 있는 연산 집약적 작접을 처리할 때

# 7.8 동시성 렌더링 관련 문제

## 티어링

상태 업데이트가 완전히 반영되기 전까지 UI가 잠시나마 일관되지 않은 상태를 보여주는 현상

`count` 가 렌더링 주기와 관계없이 `setInterval`을 통해 지속적으로 업데이트함. 애플리케이션이 렌더링되는 동안 `count` 값이 변경되어 티어링 버그가 생길 수 있다.

```jsx
import { useState, useTransition } from "react";

let count = 0;
setInterval(() => count++, 1);

export default function App() {
  const [name, setName] = useState("");
  const [isPending, startTransition] = useTransition();

  const updateName = (newValue: string) => {
    startTransition(() => {
      setName(newValue);
    });
  };

  return (
    <div>
      <input value={name} onChange={(e) => updateName(e.target.value)} />
      {isPending && <div>Loading...</div>}
      <ul>
        <li>
          <ExpensiveComponent />
        </li>
        <li>
          <ExpensiveComponent />
        </li>
        <li>
          <ExpensiveComponent />
        </li>
      </ul>
    </div>
  );
}

const ExpensiveComponent = () => {
  const now = performance.now();

  while (performance.now() - now < 100) {
    // do nothing
  }

  return <div>{count}</div>;
};
```

## useSyncExternalStore

애플리케이션의 내부 상태와 외부 상태를 동기화하는 훅

티어링 문제를 해결할 수 있다.
