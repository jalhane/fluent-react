# 가상돔

가상돔은 html 문서 자체를 객체로 모델링한 것. 사실상 일반적인 객체다.
실제돔도 그냥 객첸데 뭐가 다를까?

## 차이점

실제돔

- 브라우저 렌더링 엔진과 직접 연결됨 -> C++ 같은 저수준 언어로 구현됨
- 매우 무겁고 복잡함 -> 온 갖 리스너, 속성, 메서드 존재
- 속성 하나만 변해도 리플로우, 리페인트

가상돔

- 순수 JS 객체, 리액트 메모리가 직접 만듦
- 매우 가볍고 단순함 -> 실제 렌더링에 필요한 최소 정보
- 메모리상 객체를 바꾸는 것일 뿐 -> 사실상 화면에 아무런 변화가 없음 (가상돔 비교 시)

> 실제 건물과 청사진으로 생각하면 될듯

가상돔 - 실제돔 비교해 변경 사항을 실제돔에 반영하는 게 재조정이다.

> 실제돔에 변경 사항을 반영하는 건 커밋 단계로 알고 있는데
> 용어가 잘못된 거 아닐까?

가상돔은 실제 페이지를 건드리지 않아서 훨씬 빠르다.
자바스크립트 엔진에 종속되어 빠르고 효율적

## 실제돔

### 성능

쿼리셀렉터는 일치하는 엘리먼트를 탐색 (CSS 셀렉터를 써서) -> 문서가 비대하면 On이다.
겟엘리먼트바이아이디는 유효성 검사가 없고 id는 고유한 값이기에 O1이다. -> 이걸 써야겠네.

> 근데 얼마나 성능에 영향을 주나?

실제돔을 조작할 시 불필요한 레이아웃 계산 과정이 너무 많다. -> 단일 요소가 아니라 영향을 주는 모든 요소가 재계산될 수 있음

그래서 최적화된 API로 레이아웃 스래싱을 최소화하자.
예) getBoundingClientRect()

레이아웃 작업은 단순해도 약간의 시간이 걸린다. -> 문서가 크면 해당 지연 시간도 늘어난다.
추가, 스타일도 모두 비효율적으로 전체 레이아웃을 재계산하고 다시 그린다.
이런 밀리초가 중요하냐? -> 유저 경험에 엄청난 영향을 줄듯

### 호환성

브라우저 간 인터페이스 통일이 되지 않음.

리액트의 경우 합성 이벤트 시스템으로 이런 문제를 해결함
여러 브라우저에서 일관성을 보장한다.

- 타겟 인터페이스 통일
- 이벤트 위임
- 기능 개선
  - 온체인지 입력 시 바로
    - 실제돔은 블러되어야
  - 셀렉트 선택된 옵션 선택 시 이벤트 호출 x

## 문서 조각

돔 노드를 저장하는 가벼운 컨테이너로 실제돔에 영향 주지 않음

- 일괄 업데이트
- 메모리 효율성
- 중복 렌더링 방지

createDocumentFragment() API
작업을 그룹화해서 한 번 -> 배칭?

```ts
const ul = document.getElementById("my-list");

// 1. 메모리에 빈 DocumentFragment를 생성
const fragment = document.createDocumentFragment();

for (let i = 0; i < 100; i++) {
  const li = document.createElement("li");
  li.textContent = `Item ${i + 1}`;
  // 2. 실제 DOM이 아닌 메모리의 프래그먼트에 li를 추가 (리플로우 없음)
  fragment.appendChild(li);
}

// 3. 루프가 끝난 후, 100개의 li가 담긴 프래그먼트를 실제 DOM에 단 한번만 추가
// 이 시점에 단 한 번의 리플로우/리페인트 발생
ul.appendChild(fragment);
```

## 가상돔

메모리에 가상 표현을 만들고 그 가상 표현을 조작하도록 하는 것
브라우저가 할 필요 없음
브라우저 돔을 추상화함

### 리액트 엘리먼트

React.createElement로 만들 수 있다.

```ts
React.createElement("h1", { className: "greeting" }, "Hello, world!");

{
  "$$typeof": Symbol.for('react.element'),
  "type": "h1",
  "props": {
    "className": "greeting",
    "children": "Hello, world!"
  },
  "key": null,
  "ref": null,
  "_owner": null,
  "_store": {}
}
```

그럼 함수형 컴포넌트의 반환 값은 객체?

- $$
  typeof
  - 엘리먼트 종류를 식별하는 표시
  - 프라그먼트, 포탈, 프로파일러, 프로바이더 등
  $$
- type
  - 엘리먼트가 나타내는 컴포넌트 종류
  - 네이티브 Html 태그(문자열) 및 커스텀 컴포넌트
- props
  - 모든 프랍스
- key
  - 앨리먼트 구별하기 위한 식별표
  - 사실상 군번줄
- ref
  - 돔 노드 접근
  - 부모 컴포넌트?
- \_ower
  - 업데이트될 때 그 업데이트의 책임이 되는 컴포넌트를 결정
- \_store
  - 추가 데이터

상태 프랍이 변경되면 새로운 트리를 생성하고 디핑 알고리즘으로 이전 트리와 비교해 실제 돔에 최소한의 변경점을 반영한다.

- 두 트리 루트 노드가 다를 경우 -> 전체를 새 트리로 대체
- 루트 노드 동일 -> 변경된 속성만 노드에 적용
- 자식 노드가 다를 경우 자식만 변경
- 자식이 동일하고 순서 바뀔 경우 -> 순서만 변경
- 노드 제거 -> 실제돔 노드 제거
- 노드 추가 -> 실제돔 노드 추가
- 노드 종류 변경 -> 이전 노드 제거 새 노드 교체
- key 프랍으로 교체 확인

리렌더링이 많이 일어날 경우

- 컴포넌트 구조 변경 -> 지역 상태로 갖기
  - 상태 갖는 컴포넌트 책임 분리
- 메모이제이션

> 근데 리렌더링은 되더라도 실제 돔이 변경되지 않으니 괜찮지 않을까?
> 리렌더링 최적화는 언제?
