### 가상 DOM

가상 돔 - ( 실제 돔 객체와 유사한 ) 메모리에 구현된 DOM 객체

가상 돔은 실제 돔을 최대한 적게 수정하기 위해 고안된 방식이다.

왜 ? 실제 돔의 노드 객체와 트리를 재계산하고 reflow-repaint 하는 전체 렌더링 비용이 비싸기 때문

- 특히 렌더링이 메인 싱글 스레드에서 돌아가기 때문에 더 비용이 크다.

가상 돔과 web api 인 shadow dom 의 차이가 뭔가?

### document querySelector 와 document getElementById

당연히 정확한 타겟이 된 id 를 가진 element 를 잘 찾는다.
해시테이블 - O(1) , 하지만 해시테이블의 단점 => 해시값 충돌을 할 경우, 문제가 생길 수 있다.
( 하나의 id와 type 을 가진 element 를 여러번 재사용할 경우 발생 가능성이 높아진다. )
( sha256 ) => 해시를 생성하는거 자체의 비용도 고려.
id 를 사용하는게 항상 더 좋다고 생각할 수 없다. (portal, modal 등 하나의 컴포넌트가 전체 화면을 점유하는 경우)
한 로직 사이클 내에 한번 찾고 또 찾을 경우, 내부적으로 캐시가 적용될 수도 있지 않을까.

### 모든 트리 구조의 문제 - deps 가 깊으면 운이 나쁘면 find 비용이 커짐

최적화를 원한다면 가능하면 element 구조를 가장 심플하게 짜서 요구사항을 충족하는게 좋다.
( div 너무 감싸지 말자. )

#### 아무튼 그래서 실제 DOM API (저수준) 를 가능하면 절대 React 에서 쓰지 말자. 쓰게 되면 가상 돔은 의미가 없다.

### 성능

엘리먼트 추가, 삭제, 엘리먼트 텍스트, 속성 업데이트 등을 하면 브라우저는 트리를 재생성해야한다.

Update Element => DOM Tree + CSSOM Tree => Render Tree => Reflow => Repaint => Composite

특히나 최상위 트리의 요소 추가, 삭제, 업데이트는 그만큼 영향 범위가 커질 수 있기 때문에 가장 최하단에 가까운 요소를
건드려서 요구사항을 만족시키는 게 좋다.

#### offsetWidth => getBoundingClientRect 사용하자

- 항상 reflow 가 발생하지는 않지만, stale 상태에서 offsetWidth 를 사용하면 reflow 가 발생한다.

  - 무효화 플래그(Invalidation Flags) 브라우저는 각 요소에 대해 여러 플래그를 유지합니다:
    - needsLayout: 레이아웃 재계산 필요
    - needsRepaint: 다시 그리기 필요
    - needsComposite: 합성 필요

- 브라우저가 레이아웃 정보가 최신 상태인지 확인해야 하기 때문에 계산 비용이 발생
- ( 최악의 시나리오일 경우 ) O(n) 만큼 비용 발생
- getBoundingClientRect 은 브라우저가 여러 속성을 한번에 계산하도록 최적화되어 있다.
- **레이아웃 스레싱** 현상이 최소화 된다.
- 읽고 쓰는 작업이 자주 반복될 경우 발생하는 불필요한 레이아웃 재계산 한번에 읽고 한번에 쓰자
  ( 데이터 베이스도 replica 가 읽기용, 쓰기용이 따로 있는 것처럼...? )

#### DOM 조작시 한번에 읽고 한번에 쓰기 원칙을 적용한다면?

element 를 찾는 로직을 몰아서 위에서 적용, 초기화, 할당 => 쓰는 로직을 한번에 처리한다.

```js
const element = getElementById("element1");

[1, 2, 3, 4, 5, 6].forEach((item) => {
  element.appendChild(item);
});
```

#### 최적화 방법 1: DocumentFragment 사용

```js
const element = getElementById("element1");
const fragment = document.createDocumentFragment();

[1, 2, 3, 4, 5, 6].forEach((item) => {
  const div = document.createElement("div");
  div.textContent = item;
  fragment.appendChild(div);
});

element.appendChild(fragment); // 한 번만 DOM 조작
```

#### 최적화 방법 2: innerHTML 사용 (단순한 경우)

```js
const element = getElementById("element1");
const html = [1, 2, 3, 4, 5, 6].map((item) => `<div>${item}</div>`).join("");
element.innerHTML = html; // 한 번만 DOM 조작
```

결국, 브라우저가 레이아웃을 강제로 다시 계산하는 횟수를 최소하, 계산할때 한번의 작업으로 필요한 정보를 가져오도록 한다.

### 리액트는 이런 작업을 알아서 처리한다!

- 가상 돔을 실제 돔 작업 간의 중간 계층으로 활용

### 브라우저 간 호환성

- 실제 DOM API 는 브라우저 간에 호환되지 않는 경우가 간혹 있다.

리액트 합성 이벤트 시스템이 이를 해결하고자 나왔다. SyntheticEvent 브라우저 기본 이벤트를 둘러싼 래퍼 객체.
여러 브라우저에서 일관성을 보장하기 위해 설계되었다. ( 외부 API - Wrapper - 비즈니스 로직 )

#### 통합 인터페이스

기본적인 자바스크립트에서 브라우저간 호환성 문제로 브라우저 이벤트 처리가 까다로웠다.
이런 부분들을 추상화해 이벤트 상화작용하는 일관된 방법을 제공해 특정 브라우저에 맞춘 개별 코드를 작성하지 않아도 되도록 했다.
( React Navtive 에서도 Bridge 아키텍처가 비슷한 느낌 )

리액트가 네이티브 이벤트를 SyntehticEvent 시스템으로 감싼 덕에 네이티브 브라우저 이벤트 시스템의 비일관성과 괴상한 특서을 마주할 일이 없다.

#### 이벤트 위임

리액트는 이벤트 리스너를 해당 엘리먼트에 직접 추가하지 않고 루트 이벤트에서 받는다

#### 다양한 기능 개선

네이티브 브라우저 이벤트의 비 일관성은 다양한 입력 엘리먼트에서 특정 이벤트를 처리하는 방식에서도 드러난다.

- onChange Event, (일부 브라우저는 blur 될때 발생) => 동작을 정규화 => 입력할때마다 발생하도록

#### 네이티브 이벤트에 접근

웹 브라우저의 네이티브 이벤트가 필요한 경우, event.nativeEvent 를 통해 접근 가능하다.
( 추상화의 이점 + 필요에 따라 유연하게 사용 가능 )

### 문서 조각 ?

- Document Fragment

DOM 노드를 저장하는 가벼운 컨테이너 기본 DOM 에 영향을 주지 않고 여러 업데이트를 수행할 수 있다.
임시 저장소라고 생각.
업데이트 작업이 완료되면 문서 조각을 DOM 에 추가하는 방식으로 리플로우, 리페인팅을 한번에 발생시킨다.

업데이트 방식이 리액트 가상 돔과 매우 유사함.

#### 일괄 업데이트, 메모리 효율성, 중복 렌더링 방지

### 리액트가 문서 조각보다 나은 점?

- diff 알고리즘을 통해 영리하게 최적화된 변경사항을 일괄적으로 반영함.

## 가상 돔 작동 방식

#### React Element

HTML element 와 같이 React element ( 자바스크립트 객체다 ) 의 트리로 표현한다.
React.createElement() 로 만든다.

#### $$typeof

- 객체가 유효한 리액트 엘리먼트인지 확인할 때 사용
- 특수한 symbol 객체 ( symbol 객체는 고유한 값에 쓸때 유용함 )
- 리액트 엘리먼트의 종류를 식별하는 표시자 역할을 한다.

#### type

- 컴포넌트 종류를 알려준다., div,span,button 등 HTML 태그 이름을 나타낸다.
- 함수인 경우, 사용자 정의 리액트 컴포넌트 JSX 반환 함수가 된다.
  - props, children 속성이 있다.

#### 렌더링 방식

- deps 로 계속 들어가다가 스칼라 값 ( 더이상 분해 되지 않는 숫자, 문자열, 불리언 단일값 ) 을 만나면
  텍스트 노드로 렌더링, null, undefined 처럼 아무것도 못만나면 아무것도 렌더링 하지 않는다.

#### ref

- 부모 컴포넌트는 이속성을 사용해 기본 DOM 노드에 대한 참조를 요청 할 수 있다.
- DOM 을 직접 조작해야 하는 경우 사용된다.

### 재조정 ( reconciliation )

리액트 컴포넌트가 렌더링 되면 리액트는 새 가상 돔 트리를 생성하고 이전 가상 돔 트리와 비교한 다음,
이전 트리를 새 트리와 일치하도록 업데이트 하는데 필요한 최소 변경 횟수를 계산한다.
이를 재조정 프로세스라 한다.

이때 비교 알고리즘은 재귀적으로 이뤄 진다. diffing 작업 과정이라고 한다.
고도로 최적화 되어 있다. 실제 돔에 적용하는 변경 횟수의 최소화를 목표로 한다.

- 두 트리 루트에 있는 노드가 다른 경우, 전체 트리를 새 트리로 대체
- 루트 노드가 동일하다면 리액트는 노드의 속성이 변경된 경우에만 업데이트 한다.
- 자식 노드가 다른 경우 리액트는 변경된 자식 노드만 업데이트 한다. 리액트는 하위 전체 트리를 다시 생성하지 않고
  변경된 노드만 업데이트 한다.
- 노드의 자식들이 동일하지만 순서가 변경된 경우, 리액트는 노드를 다시 생성하지 않도 실제돔에서 노드의 순서를 다시 설정 한다.
- 트리에서 노드가 제거 되면 실제 돔에서 노드를 제거한다.
- 트리에 새 노드가 추가되면 해당 노드를 실제 돔에 추가한다.
- 노드 종류가 변경된 경우 리액트는 이전 노드를 제거하고 변경된 노드를 생성한다.
- 노드에 key props 가 있다면 리액트는 이를 사용해 노드의 교체가 필요한지 파악한다.

### 불필요한 리렌더링

부모 컴포넌트가 리렌더링 되면 자식도 리렌더링 된다. ( 자식 props 가 변경되지 않더라도..! )
