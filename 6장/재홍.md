# 6. 서버 사이드 리액트

## 6.1 클라이언트 사이드 렌더링 한계

## SEO

- 검색 엔진 크롤러의 구현 방식은 공개되지 않았지만 여러 테스트를 통해 구글이 전체 페이지를 렌더링하고 DOM을 읽어 동적으로 생성된 컨텐츠를 색인할 수 있다는 사실이 확인됨.
- 하지만 여전히 클라이언트 사이드 렌더링은 문제가 발생할 여지가 있음
- 빈 HTML을 가져오고 그 뒤에 자바스크립트를 다운로드하고 실행하여 페이지가 동적으로 렌더링됨.
- 페이지를 읽어들인 후 다시 요청해서 전체 페이지를 렌더링하기 위한 자바스크립트를 읽어들임. 이를 네트워크 폭포라고 한다.

### 성능

- 좋지 않은 네트워크, 좋지 않은 하드웨어를 사용하면 자바스크립트를 다운로드하고 실행하는데 영향을줄 수 있다. ( 페이지가 늦게 보이는 것 )
- TTI는 사용자 참여율과 이탈률에 직접적인 영향을 미쳐 매우 중요한 측정 지표이다.

### CSR

- 네트워크 폭포 → 자바스크립트 다운로드, 실행 때문에 초기 페이지 로드가 차단되는 현상
- HTML 로딩(빈페이지) → 자바스크립트 로딩 → 초기 UI 렌더링 → 데이터 페치 → UI 업데이트

### SSR

- HTML 로딩(서버 데이터 페치, UI 렌더링) → 하이드레이션

### 보안

- CSRF를 방어할 수 있다.

## 6.2 서버 렌더링의 부상

- 완성된 HTML을 렌더링하여 완성된 페이지를 바로 볼 수 있다.
- 좋지 않은 네트워크, 좋지 않은 하드웨어를 사용하더라도 자바스크립트가 다운하고 로드할 때까지 기다리지 않고 완성된 HTML을 볼 수 있기 때문에 UX가 좋아진다.
- SEO를 개선할 수 있다.
- 핵심 컨텐츠를 서버 사이드에서 렌더링하면 자바스크립트 실행과 관계없이 기본 컨텐츠와 긴으에 접근할 수 있다.

## 6.3 하이드레이션

- 서버에서 생성되어 클라이언트로 전송된 정적 HTML에 이벤트 리스너, 여러 자바스크립트 기능을 추가하는 프로세스

1. 정적 HTML을 렌더링하는 동안 애플리케이션의 코드가 포함된 자바스크립트 번들을 다운로드하고 파싱한다.
2. 자바스크립트 번들이 로드되면 리액트는 자바스크립트 기능을 DOM 요소에 추가해 정적 HTML을 하이드레이션한다.

### 하이드레이션

- 서버에서 렌더링한다음 이후에 브라우저에서 번들을 다운로드하고 이벤트 리스너를 추가

### 재개 가능성

- 서버에서 초기 마크업과 함께 모든 인터렉션이 직렬화되어 클라이언트로 서빙.

재개 가능성이 장점이 있지만 구현에 따르는 복잡성. 약 몇 밀리초를 개선하기 위해 구현할 가치가 있는가

milliseconds make millions…

# 6.5 리액트의 서버 렌더링 API

### renderToString

- 서버에서 리액트 컴포넌트를 HTML 문자열로 렌더링할 때 사용
- 동기식으로 동작

```jsx
import { renderToString } from "react-dom/server";

function App() {
  return <div>Hello, World!</div>;
}

export default App;

const html = renderToString(<App />);

console.log(html); // <div>Hello, World!</div>
```

- 기본적으로 JSX는 아래 흐름을 거쳐 HTML로 변환된다.

`JSX → React.creatElement → React 엘리먼트 → renderToString(React element) → HTML`

### 단점

- 대규모 리액트 애플리케이션에서는 처리 속도가 느릴 수 있다. 동기식이기 때문에 이벤트 루프를 차단하고 서버가 응답하지 않게 만들 수 있다.
- 완전히 렌더링 된 대규모 HTML을 반환하므로 메모리 사용량이 과도할 수 있다.
- 스트리밍을 지원하지 않아 클라이언트로 전송하려면 HTML 문자열 전체를 생성해야 한다.
- 그래서 TTFB(서버에서 보낸 데이터를 클라이언트가 수신을 시작하기까지 걸린 시간)가 느려진다.

### renderToPipeableStream

- Node.js 스트림에 렌더링하는 보다 효율적인 서버 사이드 렌더링 API
- 응답 객체로 파이프할 수 있는 스트림을 반환하여 HTML이 렌더링되는 방식을 더 세밀하게 제어할 수 있어 Node.js 스트림과 통합할 수 있다.
- 서버 사이드 렌더링 중 비동기 데이터 페치를 더 잘 처리해주는 Suspense를 지원.
- HTML 청크를 클라이언트에 비동기적으로 전송 → 점진적 데이터 전달 가능
- TTFB 지표가 향상

### Node.js 스트림

- 출발지에서 목적지로 흐르는 데이터 흐름을 나타냄.
- 메모리를 효율적으로 처리할 수 있는 확장 가능하고 강력한 추상화 기능을 제공
- 파일 입출력, 네트워크 입출력, end-to-end 스트링을 다루는 서버 환경에서 작동

1. 읽기 가능 스트림
   - 읽을 수 있는 데이터 출처를 나타냄
   - data, end, error 같은 이벤트를 발생시킴
   - 파일에서 데이터 읽기, HTTP 요청에서 데이터 수신 등
2. 쓰기 가능 스트림
   - 데이터를 쓸 수 있는 대상을 나타냄
   - write(), end() 같은 메서드 제공
3. 양방향 스트림
   - 읽기, 쓰기 둘 다 가능한 스트림
   - 네트워크 소켓이나 통신 채널에 주로 사용됨.
4. 변환 스트림
   - 데이터가 흐르는 동안 데이터 변환을 수행하는 특수한 양방향 스트림.
   - 압축, 암호화, 압축 해제 또는 데이터 구문 분석과 같은 작업을 수행할 수 있음.

### pipe

- 서로 다른 두 개의 스트림을 연결하는 것
- 랭체인의 체인과 비슷한 느낌인 듯

### 리액트의 renderToPipeableStream

- 리액트 컴포넌트를 쓰기 가능 스트림으로 스트리밍한다.
- HTML 전체가 생성될 때까지 서버가 기다렸다가 클라이언트에 전송하는 대신, HTML 응답 청크가 준비되는 즉시 전송을 시작해 전반적인 지연 시간을 줄인다.

### renderToReadableStream

- 브라우저에서 읽을 수 있는 스트림을 반환

### 브라우저 스트림

- 웹 브라우저 내의 클라이언트 환경에서 작동하도록 설계
- 네트워크 요청, 미디어 스트리밍, 브라우저의 데이터 처리 작업에서 스트리밍 데이터를 처리

## 6.6 직접 구현하지 마세요

### 에지 케이스 및 복잡성 처리

- 비동기 데이터 페치, 코드 스플리트, 리액트 수명 주기 이벤트 관리 등 여러 에지 케이스를 해결해야한다. 너무 복잡하다. 프레임워크는 일반적인 에지 케이스에 대한 해결책이 포함되어 있다.

### 성능 최적화

- 프레임워크는 자동 코드 스플리트, 서버 렌더링, 캐시 등 많은 성능 최적화 기능을 기본으로 제공해줌.

### 개발자 경험 및 생산성

- 직접 서버 렌더링을 구현하는 것은 어렵고 시간이 많이 걸린다. 프레임워크 쓰며레임워크 쓰면 편하다.

### 모범 사례와 코딩 규칙

- 프레임워크가 시키는 대로 하면 애플리케이션 뚝딱이다.
