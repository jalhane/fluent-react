## 6장 서버 사이드 리액트

### 배경

- **리액트의 진화**: 초기엔 클라이언트 사이드 렌더링(CSR) 중심이었으나 SEO, 성능, 보안과 같은 요구가 커지며 **서버 사이드 렌더링(SSR)** 및 **스트리밍 SSR**이 중요해짐.
- **문제의식**: CSR은 JS 다운로드/파싱/실행, 데이터 패칭 이후 화면이 의미 있게 보이는 구조라 저사양 기기·느린 네트워크·크롤러 환경에서 한계가 존재.

---

## 6.1 클라이언트 사이드 렌더링 한계

### 6.1.1 검색 엔진 최적화(SEO)

- 일부 검색 엔진/크롤러는 자바스크립트를 완전하게 실행하지 못하거나 지연 실행함.
- CSR만 사용 시 초기에 **빈 화면(placeholder)** 이 노출될 수 있어 콘텐츠 인덱싱 품질 저하 위험.
- 실험적으로 구글은 다양한 방식으로 CSR을 처리하지만, **초기 HTML에 핵심 콘텐츠**를 담아 주는 SSR이 보다 안정적.
- 정리: SEO 관점에서 SSR로 의미 있는 초기 HTML을 제공하면 가시성과 색인이 개선됨.

### 6.1.2 성능(느린 네트워크·저사양 기기)

- CSR은 초기 로딩에서 JS 번들 다운로드/파싱/실행 + 데이터 패칭(Network Waterfall) 이후 렌더링이 이뤄짐.
- 결과적으로 TTI(Time to Interactive)가 늘어나고, CPU 사용량 제약 환경에서 UX 저하.
- 예시 코드: `useEffect`에서 데이터 패칭 → 콘텐츠가 늦게 표시되어 SEO/초기 경험 모두에 비효리적.

### 6.1.3 보안(CSRF 등)

- CSR은 브라우저가 자동으로 보낸 인증 쿠키를 악용한 **CSRF** 취약점 노출 가능.
- 서버 렌더링은 서버 전용 시크릿·토큰을 활용해 **요청 출처 검증/서명** 등 방어 수단을 쉽게 녹일 수 있음.
- 핵심: 민감 로직·비밀은 서버 경계 안으로, 클라이언트에는 필요한 최소 정보만.

---

## 6.2 서버 렌더링의 부상과 장점

### 왜 SSR인가

- **빠른 최초 의미 있는 페인트(FMP)**: 초기 HTML에 즉시 유용한 콘텐츠 제공.
- **저사양/약한 네트워크에서도 접근성 향상**: JS 준비를 기다리지 않아도 읽을거리 제공.
- **SEO 개선**: 크롤러가 완전한 HTML을 수월하게 인덱싱.
- **보안 이점**: 서버에서 비밀·토큰을 안전히 관리하고 검증 로직을 수행.

---

## 6.3 하이드레이션(Hydration)

### 정의

- 서버가 보낸 **정적 HTML**에 클라이언트가 **이벤트 리스너와 상호작용 기능**을 붙여 완전한 앱으로 전환하는 과정.
- 단계: 클라이언트 번들 로딩 → 이벤트 리스너 추가 → DOM 연결(하이드레이션 완료).

### 논의·비판

- 하이드레이션은 일부 앱에서 **필요 이상으로 무겁고 느림**. 이벤트 리스너/상태 연결 비용이 큼.
- 대안 개념: **재개 가능성(Resumability)**
  - 서버가 전체 UI와 상호작용 단서를 전송하고, 클라이언트는 추가 계산 없이 즉시 반응하도록 설계.
  - 목표: 하이드레이션 단계를 줄이거나 우회해 **TTI를 단축**하고 체감 성능을 높임.

#### 재개 가능성(Resumability) 자세한 설명

- **정의**: 서버에서 렌더링된 UI의 "실행 스냅샷"(상태, 이벤트 연결 힌트, 컴포넌트 경계)을 HTML에 직렬화해 함께 보낸 뒤, 클라이언트는 페이지 로드 직후 전체 번들을 재실행(hydrate)하지 않고도 즉시 이벤트에 반응할 수 있는 모델.
- **하이드레이션과의 차이**
  - 하이드레이션: 클라이언트가 초기 HTML을 기준으로 앱 코드를 다시 로드/실행해 트리를 복원한 다음 이벤트를 붙임 → 초기 비용 큼.
  - 재개 가능성: 서버가 남긴 힌트로 클라이언트는 "필요한 순간에, 필요한 경계만" 코드를 로드해 이어서 실행(resume) → 초기 비용 최소화.
- **동작 원리(개념)**
  - 서버: 컴포넌트 경계마다 식별자/이벤트 바인딩 정보/상태 스냅샷을 HTML 속성·스크립트로 주입.
  - 클라이언트: 최초에는 리스너 대리자(delegate)만 동작. 사용자가 상호작용하면 해당 경계의 모듈을 **지연 로드**해 실행을 재개하고, 필요한 부분만 점진적으로 활성화.
- **장점**
  - 초기 TTFB/TTI 개선(대규모 앱일수록 효과 큼)
  - 저사양 기기에서 CPU·메모리 소모 감소
  - 네트워크가 느려도 상호작용 경로를 빠르게 확보
- **고려사항**
  - 빌드·런타임 복잡도가 증가하고, 프레임워크 지원이 필수적
  - 디버깅/관찰성 도구 정비 필요, 프리로딩·분할 전략 설계 요구
- **관련 기술**
  - Qwik의 재개 가능 아키텍처: 하이드레이션 없이 즉시 상호작용을 목표로 함
  - Marko/Islands 아키텍처: 섬 단위 활성화로 하이드레이션 범위를 제한
  - React는 선택적 하이드레이션·스트리밍·서버 컴포넌트 등으로 비용을 줄이는 방향(정통 의미의 전면적 재개 가능은 별도 프레임워크에서 활발)
- **참고 자료**
  - Qwik Docs – Resumability: `https://qwik.builder.io/docs/concepts/resumability/`
  - Builder.io 블로그 – Resumability vs Hydration: `https://www.builder.io/blog/hydration-is-pure-overhead`
  - Marko Docs – Hydration/Islands: `https://markojs.com/docs/hydration/`

---

## 6.4 서버 렌더링 작성 방법(개념적 흐름)

> 실무에서는 Next.js/Remix 등 프레임워크 사용 권장. 아래 내용은 동작 원리를 이해하기 위한 수동 구성 개요.

1. 서버 구성(예: Express) + `react-dom/server`

- 정적 파일 서빙과 SSR 라우트 준비.
- `ReactDOMServer.renderToString(<App />)` 혹은 스트리밍 API로 HTML 생성.

2. 응답 HTML 예시(요지)

```html
<!DOCTYPE html>
<html>
  <head>
    <title>React 앱</title>
  </head>
  <body>
    <div id="root">/* 서버 렌더링된 마크업 */</div>
    <script src="/static/js/main.js" defer></script>
  </body>
</html>
```

3. 클라이언트 하이드레이션

```ts
import { hydrateRoot } from "react-dom/client";
hydrateRoot(document, <App />);
```

---

## 6.5 리액트 서버 렌더링 API

### 6.5.1 `renderToString`

- **무엇**: 리액트 엘리먼트를 **완전한 HTML 문자열**로 동기 변환.
- **장점**: 단순, 범용, 디버깅 쉬움.
- **단점**: 이벤트 루프를 블로킹, **스트리밍 미지원**, 대규모 앱에서 TTFB 증가·메모리 부담.

작동 개념: `React.createElement` 트리를 순회 → DOM에 해당하는 문자열 생성 → 한 번에 전송.

### 6.5.2 `renderToPipeableStream`(Node 전용)

- **무엇**: **스트리밍 SSR**. Node.js의 Readable/Writable 스트림으로 **청크 단위** HTML 전송.
- **핵심 콜백**:
  - `onShellReady`: 셸(초기 HTML) 준비 시점에 바로 응답 시작 → 빠른 TTFB.
  - `onAllReady`: 모든 컴포넌트 준비 후 남은 스트림 전송.
- **장점**: 대용량 앱·느린 네트워크에서 첫 페인트 가속, **Suspense 지원**으로 비동기 데이터 구간을 자연스럽게 스트리밍.
- **통합**: Express `res`에 파이프, 헤더 `text/html` 설정. 에러/abort·drain 등 스트림 이벤트 처리.

#### renderToPipeableStream 예시 코드

```ts
// server.ts - Express + 스트리밍 SSR(셸 우선, HTML 래핑, 타임아웃/에러 처리)
import express from "express";
import React from "react";
import { renderToPipeableStream } from "react-dom/server";
import App from "./App";

const app = express();
const ABORT_DELAY = 10000; // 10s

app.get("*", (req, res) => {
  let didError = false;
  res.setHeader("Content-Type", "text/html; charset=utf-8");

  // 문서의 앞부분을 먼저 전송하여 TTFB 단축
  const htmlStart = `<!DOCTYPE html><html lang="ko"><head><meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Streaming SSR</title></head><body><div id="root">`;
  const htmlEnd = `</div><script src="/static/client.js" defer></script></body></html>`;

  const { pipe, abort } = renderToPipeableStream(<App />, {
    onShellReady() {
      // 셸이 준비되면 즉시 시작
      res.statusCode = didError ? 500 : 200;
      res.write(htmlStart);
      // 스트림 종료를 우리가 제어하기 위해 end:false
      pipe(res, { end: false });
    },
    onAllReady() {
      // 나머지 청크가 준비되면 문서 마무리 후 종료
      res.write(htmlEnd);
      res.end();
    },
    onShellError(err) {
      didError = true;
      console.error("Shell error:", err);
      res.statusCode = 500;
      res.setHeader("Content-Type", "text/html; charset=utf-8");
      res.end("<!DOCTYPE html><p>서버에서 오류가 발생했습니다.</p>");
    },
    onError(err) {
      didError = true;
      console.error(err);
    },
  });

  // 너무 오래 걸리면 스트림 중단 (메모리/커넥션 보호)
  setTimeout(abort, ABORT_DELAY);
});

app.listen(3000, () =>
  console.log("Server listening on http://localhost:3000")
);
```

```tsx
// App.tsx - Suspense를 활용한 스트리밍 예시(지연되는 섹션은 뒤늦게 채워짐)
import React, { Suspense } from "react";

function delay<T>(p: Promise<T>) {
  return new Promise<T>((r) => setTimeout(async () => r(await p), 1200));
}
const Dogs = React.lazy(async () => ({
  default: function Dogs() {
    // 실제로는 서버 데이터 패칭이 Suspense 리소스와 결합될 수 있음
    return (
      <ul>
        <li>리트리버</li>
        <li>코르기</li>
        <li>말티즈</li>
      </ul>
    );
  },
}));

export default function App() {
  return (
    <div>
      <h1>Streaming SSR + Suspense</h1>
      <p>
        헤더/영역은 셸 준비 직후 표시되고, 느린 섹션은 이후 스트림으로
        채워집니다.
      </p>
      <Suspense fallback={<p>견종 목록 로딩 중…</p>}>
        <Dogs />
      </Suspense>
    </div>
  );
}
```

```ts
// 선택 사항: 압축과 캐시 헤더를 결합 (권장)
import compression from "compression";
app.use(compression());
// 적절한 캐시 정책을 설정해 재다운로드 비용 절감 (예: 정적 번들)
// app.use('/static', express.static('dist', { maxAge: '1y', immutable: true }));
```

### 6.5.3 `renderToReadableStream`(웹/엣지 런타임)

- **무엇**: 표준 **Web Streams** 기반 ReadableStream을 반환하는 SSR 스트리밍.
- **사용처**: 브라우저/엣지·Workers 환경(예: Vercel Edge, Cloudflare Workers)과의 궁합이 좋음.
- **장점**: 표준 프라미스/스트림 API, 환경 이식성.

### 6.5.4 어떤 API를 언제 쓸까

- **간단한/소규모·레거시 호환**: `renderToString`
- **Node 서버 · 성능/TTFB 최적화 · Suspense 활용**: `renderToPipeableStream`
- **엣지/웹 표준 스트림 환경**: `renderToReadableStream`
- **추가 팁**: `preload/prefetch/preconnect` 힌트, CSS 처리 전략, 데이터 스트리밍과의 결합을 고려.

---

## 6.6 직접 구현하지 마세요(프레임워크 권장)

### 권장 이유

- **보안**: 민감 데이터가 클라이언트로 새지 않도록 안전한 경계 제공(예: 라우트별 서버 전용 데이터).
- **성능 최적화**: 자동 코드 분할, 스트리밍 SSR, 라우팅 수준 캐싱 등 모범 구현 내장.
- **개발자 경험**: 데이터 패칭/라우팅/빌드 파이프라인을 일관 API로 제공.
- **모범 사례 축적**: 커뮤니티·도구 체인과의 호환(Next.js 13+의 서버 컴포넌트/스트리밍 등).

### 잘못된 수동 구현의 위험 예시(요지)

- 서버 캐시 변수를 전역으로 두고 `/user/:userId` 요청에 재사용하면 **다른 사용자 데이터가 섞여** 반환될 수 있음.
- 프레임워크의 **경계 캐싱/격리된 데이터 페칭 모델**을 사용해 데이터 누수를 방지해야 함.

---

## 전체 흐름 한눈에 보기

1. 문제 인식: CSR의 SEO/성능/보안 한계.
2. 해결 전략: SSR로 초기 HTML 제공 → 하이드레이션으로 상호작용 부여.
3. 현대 접근: **스트리밍 SSR + Suspense**로 TTFB 개선, 점진적 데이터/뷰 전송.
4. 선택 가이드: 환경별 SSR API 선택(`renderToString`/`renderToPipeableStream`/`renderToReadableStream`).
5. 실무 원칙: **직접 구현보다 프레임워크(Next.js, Remix 등)** 채택.

---

## 체크리스트(요약 적용 가이드)

- **SEO**: 핵심 콘텐츠를 초기 HTML로 제공하는가?
- **TTFB/성능**: 스트리밍 SSR·Suspense·preload/prefetch를 적용했는가?
- **보안**: 비밀/토큰/검증은 서버 경계 안에서 처리되는가?
- **하이드레이션 비용**: 번들 크기·이벤트 리스너 부착 시간을 계측/최적화했는가?
- **환경 적합성**: Node면 `renderToPipeableStream`, 엣지/웹이면 `renderToReadableStream` 고려.
- **프레임워크 사용**: Next.js/Remix의 라우팅·데이터·캐싱 모범 사례를 적극 활용.

---

### 참고 코드 스케치(개념용, 축약)

```ts
// Node + Express + 스트리밍 SSR(요지)
import express from "express";
import React from "react";
import { renderToPipeableStream } from "react-dom/server";
import App from "./App";

const app = express();
app.get("*", (req, res) => {
  res.setHeader("Content-Type", "text/html");
  const { pipe } = renderToPipeableStream(<App />, {
    onShellReady() {
      pipe(res);
    },
    onError(err) {
      console.error(err);
    },
  });
});
app.listen(3000);
```

```ts
// 클라이언트 하이드레이션(요지)
import { hydrateRoot } from "react-dom/client";
import App from "./App";
hydrateRoot(document, <App />);
```

---

## 결론

SSR은 단순 SEO 개선을 넘어 저사양 기기 경험·보안·TTFB를 종합적으로 향상시키는 현대 리액트 앱의 핵심 구성요소다. 특히 **스트리밍 SSR + Suspense**는 초기 가시성과 상호작용 가능 시점을 앞당겨 사용자 만족도를 높인다. 실무에서는 **프레임워크를 우선 채택**해 검증된 모범사례와 최적화를 활용하는 것이 비용·품질·속도 면에서 가장 합리적이다.
