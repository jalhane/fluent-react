### 2.1 자바스크립트 XML?

JSX(JavaScript XML)는 React에서 사용하는 JavaScript의 확장 문법이다. HTML과 유사한 마크업을 JavaScript 코드 내에 직접 작성할 수 있게 해주는 문법적 설탕(syntactic sugar)이다.

JSX의 특징:

- HTML과 유사한 태그 기반 문법
- JavaScript 표현식을 중괄호 {} 안에 삽입 가능
- 컴포넌트를 선언적으로 작성할 수 있음
- React.createElement() 호출로 컴파일됨 ( 17 버전 이후 부터는 \_jsx 특수 함수 호출로 컴파일 됨 기능은 동일 )

JSX의 핵심 개념:

1. **선언적 UI**: HTML과 유사한 문법으로 UI를 직관적으로 작성
2. **JavaScript 통합**: 모든 JavaScript 표현식과 로직을 JSX 내에서 사용 가능
3. **컴파일 타임 변환**: 브라우저가 실행하기 전에 일반 JavaScript로 변환
4. **타입 안전성**: TypeScript와 함께 사용 시 컴파일 타임에 오류 검출

JSX 규칙:

- 모든 태그는 닫혀야 함 (self-closing 태그 포함)
- 최상위 요소는 하나여야 함 (Fragment 사용 가능)
- JavaScript 예약어는 camelCase로 사용 (class → className)
- 인라인 스타일은 객체로 전달

  2.2 JSX의 장점

JSX는 React 개발에서 많은 장점을 제공하며, 이는 현대적인 웹 개발의 핵심 요소가 되었다.

### 1. 가독성과 직관성

- **HTML과 유사한 문법**: 웹 개발자들이 익숙한 HTML 태그 구조를 그대로 사용
- **시각적 명확성**: 컴포넌트의 구조와 계층을 한눈에 파악 가능
- **의도 파악 용이**: UI가 어떻게 구성될지 코드만 봐도 쉽게 이해

```jsx
// JSX 사용 - 직관적이고 읽기 쉬움
const UserProfile = ({ user }) => (
  <div className="user-profile">
    <img src={user.avatar} alt={user.name} />
    <h2>{user.name}</h2>
    <p>{user.bio}</p>
    <button onClick={() => handleEdit(user.id)}>편집</button>
  </div>
);

// 일반 JavaScript - 복잡하고 읽기 어려움
const UserProfile = ({ user }) =>
  React.createElement(
    "div",
    { className: "user-profile" },
    React.createElement("img", { src: user.avatar, alt: user.name }),
    React.createElement("h2", null, user.name),
    React.createElement("p", null, user.bio),
    React.createElement(
      "button",
      { onClick: () => handleEdit(user.id) },
      "편집"
    )
  );
```

### 2. JavaScript와의 완벽한 통합

- **동적 콘텐츠**: JavaScript 변수, 함수, 표현식을 자유롭게 사용
- **조건부 렌더링**: 삼항 연산자, 논리 연산자로 간단하게 구현
- **반복 렌더링**: map, filter 등 배열 메서드와 함께 사용
- **이벤트 처리**: JavaScript 함수를 직접 이벤트 핸들러로 연결

### 3. 컴포넌트 기반 아키텍처 지원

- **재사용성**: 컴포넌트를 독립적인 단위로 분리하여 재사용
- **조합성**: 작은 컴포넌트들을 조합하여 복잡한 UI 구성
- **유지보수성**: 각 컴포넌트의 책임을 명확히 분리
- **테스트 용이성**: 개별 컴포넌트를 독립적으로 테스트 가능

### 2.3 JSX의 약점

JSX는 많은 장점을 제공하지만, 개발 과정에서 마주칠 수 있는 단점들도 존재한다. 이러한 약점들을 이해하고 적절히 대응하는 것이 중요하다.

#### 1. 학습 곡선과 진입 장벽

- **새로운 문법**: HTML과 유사하지만 완전히 동일하지 않은 JSX 전용 문법 학습 필요
- **React 지식 요구**: JSX만으로는 부족하고 React의 컴포넌트 생명주기, 훅 등 추가 학습 필요
- **개발 환경 설정**: Babel, Webpack 등 빌드 도구 설정과 이해 필요
- **팀 온보딩**: 새로운 팀원이 JSX와 React 생태계에 적응하는 데 시간 소요

#### 2. 컴파일 과정의 복잡성

- **빌드 단계 필요**: JSX는 브라우저에서 직접 실행할 수 없어 컴파일 과정 필수
- **번들 크기 증가**: Babel 플러그인과 런타임 코드로 인한 번들 크기 증가
- **빌드 시간**: 대규모 프로젝트에서 JSX 컴파일로 인한 빌드 시간 증가
- **소스맵 복잡성**: 컴파일된 코드와 원본 JSX 간의 디버깅 복잡성

```jsx
// JSX 코드
const element = <div className="container">Hello World</div>;

// 컴파일된 JavaScript (Babel 출력)
var element = React.createElement(
  "div",
  {
    className: "container",
  },
  "Hello World"
);

// 번들러를 통한 최종 출력 (압축됨)
var e = React.createElement("div", { className: "container" }, "Hello World");
```

#### 3. HTML과의 차이점으로 인한 혼란

- **속성명 차이**: HTML의 `class` → JSX의 `className`, `for` → `htmlFor`
- **이벤트 핸들러**: `onclick` → `onClick`, `onsubmit` → `onSubmit`
- **스타일 속성**: 문자열이 아닌 객체로 전달, camelCase 사용
- **자체 닫는 태그**: `<img>` → `<img />`, `<input>` → `<input />`

```jsx
// HTML
<div class="container" onclick="handleClick()" style="background-color: red;">
  <label for="name">이름:</label>
  <input type="text" id="name">
  <img src="avatar.jpg">
</div>

// JSX
<div className="container" onClick={handleClick} style={{ backgroundColor: 'red' }}>
  <label htmlFor="name">이름:</label>
  <input type="text" id="name" />
  <img src="avatar.jpg" />
</div>
```

### 2.4 내부 동작

JSX가 어떻게 작동하는지 이해하는 것은 React 개발의 핵심이다. JSX는 단순한 문법적 설탕이 아니라, 컴파일 타임에 JavaScript로 변환되는 복잡한 시스템이다.

#### 2.4.1 코드는 어떻게 작동하나요?

JSX 코드가 실제로 어떻게 실행되는지 단계별로 살펴보자.

#### 일반적인 컴파일 과정

일반적인 프로그래밍 언어의 컴파일 과정과 JSX의 트랜스파일 과정은 근본적으로 다른 방식으로 작동한다.

##### 전통적인 컴파일 과정

```javascript
// C/C++ 컴파일 과정 예시
// 1. 전처리 (Preprocessing)
#include <stdio.h>
#define MAX_SIZE 100

// 2. 컴파일 (Compilation)
int main() {
    int arr[MAX_SIZE];
    for(int i = 0; i < MAX_SIZE; i++) {
        arr[i] = i;
    }
    return 0;
}

// 3. 어셈블리 생성
// 4. 링킹 (Linking)
// 5. 실행 파일 생성 (machine code)
```

**전통적 컴파일의 특징:**

- **소스 코드 → 기계어**: 직접 실행 가능한 네이티브 코드 생성
- **플랫폼 의존적**: 특정 CPU 아키텍처에 맞는 기계어 생성
- **최적화**: 컴파일 타임에 코드 최적화 수행
- **단일 단계**: 컴파일 후 바로 실행 가능

##### JSX 트랜스파일 과정

```jsx
// 원본 JSX 코드
const Component = ({ name, age }) => (
  <div className="user-card">
    <h2>{name}</h2>
    <p>나이: {age}세</p>
    <button onClick={() => alert(`Hello, ${name}!`)}>인사하기</button>
  </div>
);

// 1단계: JSX → JavaScript (Babel)
var Component = function Component(_ref) {
  var name = _ref.name,
    age = _ref.age;
  return React.createElement(
    "div",
    {
      className: "user-card",
    },
    React.createElement("h2", null, name),
    React.createElement("p", null, "나이: ", age, "세"),
    React.createElement(
      "button",
      {
        onClick: function onClick() {
          return alert("Hello, " + name + "!");
        },
      },
      "인사하기"
    )
  );
};

// 2단계: JavaScript → 최적화된 JavaScript (Webpack/Rollup)
// 3단계: 번들링 및 압축
// 4단계: 브라우저에서 실행 (JavaScript 엔진이 해석)
```

**JSX 트랜스파일의 특징:**

- **JSX → JavaScript**: 실행 가능한 JavaScript 코드로 변환
- **플랫폼 독립적**: 모든 JavaScript 런타임에서 실행 가능
- **런타임 최적화**: JavaScript 엔진이 런타임에 최적화 수행
- **다단계 과정**: 트랜스파일 → 번들링 → 실행

#### 컴파일 vs 트랜스파일 비교

| 구분              | 전통적 컴파일            | JSX 트랜스파일           |
| ----------------- | ------------------------ | ------------------------ |
| **입력**          | 고급 언어 (C, C++, Java) | JSX (JavaScript 확장)    |
| **출력**          | 기계어 (Machine Code)    | JavaScript               |
| **실행 환경**     | 특정 CPU 아키텍처        | JavaScript 런타임        |
| **최적화 시점**   | 컴파일 타임              | 런타임 (JavaScript 엔진) |
| **플랫폼 호환성** | 제한적                   | 높음 (크로스 플랫폼)     |
| **빌드 시간**     | 빠름                     | 상대적으로 느림          |
| **런타임 성능**   | 매우 빠름                | JavaScript 엔진에 의존   |
| **디버깅**        | 어려움 (기계어)          | 쉬움 (JavaScript)        |

##### 실제 트랜스파일 과정 상세 분석

```jsx
// 1. JSX 파싱 및 AST 생성
const jsxCode = `
  <div className="container">
    <h1>Hello, {userName}!</h1>
    <p>Welcome to React</p>
  </div>
`;

// Babel이 생성하는 AST (Abstract Syntax Tree)
const ast = {
  type: "JSXElement",
  openingElement: {
    type: "JSXOpeningElement",
    name: { type: "JSXIdentifier", name: "div" },
    attributes: [
      {
        type: "JSXAttribute",
        name: { type: "JSXIdentifier", name: "className" },
        value: { type: "StringLiteral", value: "container" },
      },
    ],
  },
  children: [
    {
      type: "JSXElement",
      openingElement: {
        type: "JSXOpeningElement",
        name: { type: "JSXIdentifier", name: "h1" },
      },
      children: [
        { type: "JSXText", value: "Hello, " },
        {
          type: "JSXExpressionContainer",
          expression: { type: "Identifier", name: "userName" },
        },
        { type: "JSXText", value: "!" },
      ],
    },
  ],
};

// 2. AST를 JavaScript 코드로 변환
// 3. 코드 최적화 및 압축
// 4. 최종 JavaScript 출력
```

##### 트랜스파일의 장단점

**장점:**

- **크로스 플랫폼**: 모든 JavaScript 환경에서 실행 가능
- **점진적 개선**: 새로운 JavaScript 기능을 구형 브라우저에서도 사용 가능

**단점:**

- **성능 오버헤드**: 런타임에 JavaScript 엔진이 해석해야 함
- **번들 크기**: 트랜스파일러와 폴리필로 인한 크기 증가
- **빌드 복잡성**: 여러 단계의 빌드 과정 필요
- **디버깅 복잡성**: 원본 코드와 실행 코드 간의 차이

#### JIT 컴파일과 JavaScript 성능 최적화

JavaScript 엔진의 JIT(Just-In-Time) 컴파일은 트랜스파일된 코드의 성능을 크게 향상시키는 핵심 기술이다.

##### JIT 컴파일이란?

JIT 컴파일은 JavaScript 코드를 실행하는 도중에 자주 사용되는 코드 부분을 기계어로 컴파일하여 성능을 향상시키는 기술이다.

```javascript
// JIT 컴파일 대상이 되는 코드 패턴
function calculateSum(numbers) {
  let sum = 0;
  for (let i = 0; i < numbers.length; i++) {
    sum += numbers[i];
  }
  return sum;
}

// 이 함수가 여러 번 호출되면 JIT 컴파일러가 최적화
const largeArray = Array.from({ length: 1000000 }, (_, i) => i);
console.time("JIT optimized");
for (let i = 0; i < 100; i++) {
  calculateSum(largeArray);
}
console.timeEnd("JIT optimized");
```

##### JIT 컴파일의 단계별 과정

```javascript
// 1. 인터프리터 단계 (초기 실행)
function processData(data) {
  let result = [];
  for (let i = 0; i < data.length; i++) {
    if (data[i] > 0) {
      result.push(data[i] * 2);
    }
  }
  return result;
}

// 2. 베이스라인 컴파일 (Baseline Compilation)
// 자주 실행되는 코드를 중간 표현(IR)으로 컴파일

// 3. 최적화 컴파일 (Optimized Compilation)
// 핫 패스(hot path)를 기계어로 컴파일
// 인라인화, 루프 언롤링, 제거 등 최적화 수행

// 4. 디옵티마이제이션 (Deoptimization)
// 가정이 틀렸을 때 최적화된 코드를 폐기하고 인터프리터로 복귀
```

##### JIT vs AOT 컴파일 비교

| 구분              | JIT 컴파일            | AOT 컴파일 |
| ----------------- | --------------------- | ---------- |
| **컴파일 시점**   | 런타임 (실행 중)      | 빌드 타임  |
| **최적화 정보**   | 런타임 프로파일링     | 정적 분석  |
| **메모리 사용량** | 높음 (코드 캐시)      | 낮음       |
| **시작 시간**     | 빠름                  | 느림       |
| **최적화 품질**   | 높음 (동적 정보 활용) | 제한적     |
| **적용 분야**     | JavaScript, Java      | C++, Rust  |

##### JIT 컴파일의 한계와 주의사항

```javascript
// JIT 컴파일을 방해하는 패턴들

// 1. 타입 불안정성
function typeUnstable(value) {
  if (typeof value === "number") {
    return value + 1;
  } else if (typeof value === "string") {
    return value.length;
  }
  return null;
}

// 2. 동적 속성 추가/삭제
function dynamicObject() {
  const obj = { a: 1, b: 2 };
  obj.c = 3; // 숨겨진 클래스 변경
  delete obj.a; // 숨겨진 클래스 변경
  return obj;
}

// 3. eval 사용
function withEval(code) {
  return eval(code); // JIT 최적화 불가능
}

// 4. try-catch 블록
function withTryCatch() {
  try {
    return someOperation();
  } catch (error) {
    // 에러 처리
    return null;
  }
}
```

1. **JSX 파싱**: Babel이 JSX 코드를 파싱하여 AST(Abstract Syntax Tree) 생성
2. **변환**: JSX 요소를 `React.createElement()` 호출로 변환
3. **최적화**: 불필요한 코드 제거 및 최적화
4. **출력**: 실행 가능한 JavaScript 코드 생성

```jsx
// 원본 JSX 코드
const element = (
  <div className="container">
    <h1>Hello, {userName}!</h1>
    <p>Welcome to React</p>
  </div>
);

// Babel이 변환한 코드 (React 17 이전)
var element = React.createElement(
  "div",
  { className: "container" },
  React.createElement("h1", null, "Hello, ", userName, "!"),
  React.createElement("p", null, "Welcome to React")
);

// React 17 이후 (자동 JSX 변환)
var element = _jsx("div", {
  className: "container",
  children: [
    _jsx("h1", {
      children: ["Hello, ", userName, "!"],
    }),
    _jsx("p", {
      children: "Welcome to React",
    }),
  ],
});
```

#### React.createElement() 함수의 동작

```javascript
// React.createElement의 내부 동작
React.createElement = function (type, config, ...children) {
  // 1. props 객체 생성
  const props = {};

  if (config != null) {
    // key와 ref는 별도로 처리
    if (hasValidRef(config)) {
      props.ref = config.ref;
    }
    if (hasValidKey(config)) {
      props.key = config.key;
    }

    // 나머지 props 복사
    for (let propName in config) {
      if (
        hasOwnProperty.call(config, propName) &&
        !RESERVED_PROPS.hasOwnProperty(propName)
      ) {
        props[propName] = config[propName];
      }
    }
  }

  // 2. children 처리
  const childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children[0];
  } else if (childrenLength > 1) {
    const childArray = Array(childrenLength);
    for (let i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // 3. ReactElement 객체 생성
  return ReactElement(
    type,
    key,
    ref,
    self,
    source,
    ReactCurrentOwner.current,
    props
  );
};
```

### 2.4.2 JSX로 자바스크립트 구문 확장하기

JSX는 JavaScript의 표현식과 문법을 확장하여 선언적 UI 작성이 가능하게 한다.

#### JavaScript 표현식과 JSX 혼합

```jsx
// 조건부 렌더링
const ConditionalComponent = ({ isLoggedIn, user }) => {
  if (isLoggedIn) {
    return (
      <div>
        <h3>환영합니다, {user.name}님!</h3>
        <button>로그아웃</button>
      </div>
    );
  }

  return (
    <div>
      <h3>로그인이 필요합니다</h3>
      <button>로그인</button>
    </div>
  );
};

// 삼항 연산자
const Greeting = ({ hour }) => (
  <div>
    <h1>
      {hour < 12
        ? "좋은 아침입니다!"
        : hour < 18
        ? "좋은 오후입니다!"
        : "좋은 저녁입니다!"}
    </h1>
  </div>
);
```

2.5 JSX 프라그마

JSX 프라그마(Pragma)는 JSX 코드가 어떤 함수로 변환될지를 결정하는 중요한 설정이다. 이는 JSX의 핵심 동작 원리를 이해하는 데 필수적이다.

## JSX 프라그마란?

JSX 프라그마는 JSX 요소를 JavaScript 함수 호출로 변환할 때 사용할 함수를 지정하는 지시어이다. 기본적으로는 `React.createElement`를 사용하지만, 필요에 따라 다른 함수를 사용할 수 있다.

### 기본 프라그마 설정

```jsx
// 파일 상단에 프라그마 설정
/** @jsx React.createElement */
// 또는
/* @jsx React.createElement */

// 이제 JSX는 React.createElement로 변환됨
const element = <div>Hello World</div>;
// 변환 결과: React.createElement("div", null, "Hello World");
```

### 커스텀 프라그마 사용

```jsx
// 커스텀 함수를 사용하는 경우
/** @jsx h */
// 또는
/* @jsx h */

// h 함수를 사용하여 JSX 변환
const element = <div className="container">Content</div>;
// 변환 결과: h("div", { className: "container" }, "Content");

// h 함수 정의 예시 (Preact 스타일)
function h(type, props, ...children) {
  return {
    type,
    props: props || {},
    children: children.flat(),
  };
}
```

## React 17+ 자동 JSX 변환

React 17부터는 별도의 프라그마 설정 없이도 자동으로 JSX가 변환된다.

### 자동 변환의 장점

- **설정 불필요**: 별도의 프라그마 주석이나 import 불필요
- **번들 크기 감소**: React.createElement import 제거 가능
- **성능 향상**: 최적화된 \_jsx 함수 사용

```jsx
// React 17 이전 (수동 설정 필요)
import React from "react";

const Component = () => <div>Hello</div>;
// React.createElement("div", null, "Hello")로 변환

// React 17 이후 (자동 변환)
const Component = () => <div>Hello</div>;
// _jsx("div", { children: "Hello" })로 자동 변환
```

## 프라그마별 변환 결과 비교

### React.createElement 사용

```jsx
/** @jsx React.createElement */
const element = <div className="test">Hello</div>;

// 변환 결과
var element = React.createElement("div", { className: "test" }, "Hello");
```

### \_jsx 함수 사용 (React 17+)

```jsx
// 자동 변환
const element = <div className="test">Hello</div>;

// 변환 결과
var element = _jsx("div", {
  className: "test",
  children: "Hello",
});
```
