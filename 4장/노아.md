4장 재조정 이해하기

가상돔은 UI 상태 청사진이다. 이 청사진을 가지고 재조정이라는 프로세스를 통해 주어진 호스트 환경에서 현실로 만든다.
JSX => React Element Tree (React CreateElement)

일괄 처리
DOM 에 내장된 API 브라우저의 문서조각(DocumentFragment) 가벼운 컨테이너로 임시 스테이징 영역처럼 동작
실제 돔에 영향을 주지않고 여러 변경사항을 반영한다. 한번의 리플로우 리페인팅이 발생한다.

비슷한 맥락에서 리액트는 재조정 과정에서 여러 가상 돔 업데이트를 모아 한번의 업데이트로 결합한 후 실제 돔에 일괄 처리 한다.

실제 돔 업데이트하는 횟수를 줄여 웹 어플리케이션의 성능이 개선된다.

// count 일괄 처리 함수 예시 구현

```javascript
// 일괄 처리를 위한 배치 업데이트 예시
class BatchUpdater {
  constructor() {
    this.pendingUpdates = [];
    this.isBatchingUpdates = false;
  }

  // 배치 업데이트 시작
  batchUpdate(callback) {
    this.isBatchingUpdates = true;
    try {
      callback();
      this.flushUpdates();
    } finally {
      this.isBatchingUpdates = false;
    }
  }

  // 업데이트 큐에 추가
  enqueueUpdate(update) {
    this.pendingUpdates.push(update);

    // 배치 모드가 아닐 때만 즉시 실행
    if (!this.isBatchingUpdates) {
      this.flushUpdates();
    }
  }

  // 모든 대기 중인 업데이트를 한번에 처리
  flushUpdates() {
    if (this.pendingUpdates.length === 0) return;

    // 모든 업데이트를 한번에 처리
    const updates = [...this.pendingUpdates];
    this.pendingUpdates = [];

    // 실제 DOM 업데이트는 한번만 발생
    this.performDOMUpdate(updates);
  }

  // DOM 업데이트 수행 (리플로우/리페인팅 한번만 발생)
  performDOMUpdate(updates) {
    console.log("DOM 업데이트 시작 - 리플로우/리페인팅 한번만 발생");

    updates.forEach((update) => {
      console.log(`업데이트 처리: ${update.type} - ${update.value}`);
    });

    console.log("DOM 업데이트 완료");
  }
}

// 사용 예시
const updater = new BatchUpdater();

// 여러 상태 변경을 배치로 처리
updater.batchUpdate(() => {
  updater.enqueueUpdate({ type: "count", value: 1 });
  updater.enqueueUpdate({ type: "count", value: 2 });
  updater.enqueueUpdate({ type: "count", value: 3 });
  // 이 시점에서는 DOM 업데이트가 발생하지 않음
});

// 개별 업데이트 (즉시 실행)
updater.enqueueUpdate({ type: "count", value: 4 });
```

**일괄 처리의 장점:**

1. **성능 향상**: 여러 DOM 업데이트를 모아서 한번에 처리
2. **리플로우/리페인팅 최소화**: 브라우저 렌더링 최적화
3. **사용자 경험 개선**: 부드러운 애니메이션과 반응성

**React의 실제 구현:**
React는 내부적으로 `unstable_batchedUpdates`와 유사한 메커니즘을 사용하여 여러 상태 업데이트를 배치로 처리합니다.

### 리액트 16 미만 오래된 스택 재조정자

#### 스택 재조정자

LIFO 스택 구조 푸시와 팝이라는 두가지 작업이 있다.

예전에 사용되던 리액트 재조정자는 스택 기반 알고리즘을 사용해서 새 가상 트리를 이전 가상 트리랑 비교하고 그에 따라 DOM 을 업데이트 했다.

필수적이지 않지만 계산 비용이 비싼 컴포넌트가 렌더링을 막아버리면 사용자 입력이 눈에 띄게 느려진다.
사용자 입력처럼 우선순위가 높은 렌더링 작업이 끼어들때 현재 진행 중인 렌더링 작업을 멈출 수 있어야 한다.

스택 재조정자는 업데이트 우선순위를 설정하지 않는다. 가상 트리에 대한 업데이트는 추가된 순서대로 실행되었다.

계산 비용이 크거나 좋아요 수가 업데이트가 실행되는데 시간이 오래 걸리면 업데이트 도중 사용자가 어플리케이션과 상호작용 할려고 할때
사용자 인터페이스가 눈에 띄게 느려지거나 끊김 현상이 생길 수 있다.

#### 파이버 재조정자

파이버 재조정자에는 조정자를 위한 작업단위를 나타내는 파이버라는 데이터 구조가 사용된다.
파이버는 리액트 엘리먼트에서 생성되는데 파이버는 상태를 저장하고 수명이 긴 반면 리액트 엘리먼트는 임시적이고 상태가 없다는 것이다.

'특정 시점에 존재하는 실제 컴포넌트 트리를 나타내는 리액트 내부 데이터 구조'라고 설명한다.
가상 돔이 엘리먼트의 트리를 표현하는 것과 비슷

#### 데이터 구조로서의 파이버

업데이트의 우선순위를 정하고 이에 따라 동시 실행을 가능케 해서 리액트 성능, 응답성을 향상 시킨다.

데이터 구조 = 리액트 컴포넌트 인스턴스와 그 상태를 표현
변경 가능한 인스턴스로 설계되었다. ( 조정 과정에서 필요에 따라 업데이트 되고 재배치 된다. )

파이버 노드의 각 인스턴스에는 해당 컴포넌트에 대한 정보, props, 상태, 하위 컴포넌트 등이 포함
컴포넌트 트리에서 위치 정보, 파이버 재조정자가 업데이트 우선순위를 정하고 실행하는 데 사용하는 메타 데이터도 들어있다.

#### tag

- 각 컴포넌틔 유형(클래스 컴포넌트, 함수 컴포넌트, 서스펜스 및 오류 경계, 조각(Fragment) 등) 에는 고유한 숫자 ID 가 파이버로 설정된다.

#### type

- App 은 파이버가 나타내는 함수 또는 클래스 컴포넌트를 나타낸다.

#### props

- 컴포넌트에 대한 입력 프롭 또는 함수에 대한 입력 인수를 나타낸다.

#### stateNode

- 이 파이버가 나타내는 App 컴포넌트의 인스턴스다. 컴포넌트 트리에서 위치
  - return, child, sibling, index 파이버 재조정자는 이를 사용해 트리를 순회한다.

파이버 재조정에는 현재 파이버 트리와 다음 파이버 트리를 비교해 어느 노드를 업데이트 추가 제거 할지 파악하는 작업이 있다.
조정 과정 중, 가상 돔의 각 리액트 엘리먼트에 대해 파이버 노드를 생성한다.
createFiberFromTypeAndProps 타입과 프롭은 리액트 엘리먼트라고 부를 수 있다.
엘리먼트에서 파생된 파이버를 반환한다.

파이버 노드가 생성되면 파이버 재조정자는 작업 루프 ( work loop ) 를 사용해 사용자 인터페이스를 업데이트 한다.
작업 루프는 루트 파이버 노드에서 시작해 컴포넌트 트리를 따라 내려가면서 업데이트가 필요한 경우 각 파이버 노드를 '더티'로 표시한다.

끝애 도달하면 다시 순회하면서 브라우저의 돔 트리와는 분리된 새 돔 트리를 메모리에 생성한다.

새 돔 트리는 이후 화면에 반영된다. 반영된다는 다른 말로 flushed 라고 한다.

이 작업은 두가지 함수로 표현할 수 있다.
'beginWork' (작업 시작) 은 위에서 아래로 이동하며 컴포넌트르 '업데이트가 필요함' 으로 표시하고
'completeWork' (작업 완료) 는 다시 위로 이동하면서 브라우저에서 분리된 실제 돔 엘리먼트 트리를 메모리에 구성한다.

이런 오프스크린 렌더링 프로세스는 사용자가 볼 수 없으므로 언제든지 중단하고 버릴 수 있다.

**오프스크린 렌더링이란?**
사용자 화면에 보이지 않는 메모리 공간에서 DOM을 미리 구성하는 과정입니다.

**구체적인 예시:**

```javascript
// 1. 사용자가 스크롤을 빠르게 내리는 상황
function handleScroll() {
  // 스크롤 이벤트가 발생할 때마다
  // React는 화면 밖의 컴포넌트들을 메모리에서 렌더링 시작
  const offscreenComponents = renderOffscreenComponents();

  // 하지만 사용자가 계속 스크롤하면...
  if (userIsScrollingFast) {
    // 진행 중인 렌더링을 중단하고 버림
    cancelOffscreenRendering();

    // 새로운 위치의 컴포넌트 렌더링 시작
    startNewRendering();
  }
}

// 2. 타이핑 중인 상황
function handleTyping() {
  // 사용자가 타이핑 중일 때
  // React는 검색 결과를 미리 렌더링하려고 시도
  const searchResults = renderSearchResults();

  // 하지만 사용자가 계속 타이핑하면...
  if (userIsStillTyping) {
    // 이전 렌더링 결과를 버리고
    discardPreviousResults();

    // 새로운 입력에 맞는 결과만 렌더링
    renderNewResults();
  }
}
```

**왜 중단하고 버릴 수 있나요?**

1. **사용자 경험**: 화면에 보이지 않는 작업을 계속하는 것보다 사용자 입력에 반응하는 것이 중요
2. **성능 최적화**: 불필요한 계산을 줄여서 실제 필요한 렌더링에 집중
3. **리소스 절약**: 메모리와 CPU 사용량을 효율적으로 관리

**실제 React 동작:**

- React 18의 Concurrent Features에서 이런 동작이 가능
- `startTransition`, `useDeferredValue` 등으로 구현
- 사용자 입력이 우선순위가 높을 때 낮은 우선순위 작업을 중단

#### 파이버 아키텍처

다음 화면을 화면 밖에서 준비한 다음 현재 화면으로 내보내는 '더블 버퍼링'
게임 엄계의 개념에서 착안했다.

#### 더블 버퍼링

컴퓨터 그래픽 및 비디오 처리에서 깜빡임을 줄이고 체감 성능을 개선하는 기술이다.
이미지나 프레임을 저장하기 위한 두개의 버퍼(메모리 공간)을 생성하고 일정한 간격으로
두 버퍼를 전환해 최종 이미지나 동영상을 표시한다.

실제 더블 버퍼링이 작동하는 방식은 아래와 같다.

1. 첫번째 버퍼가 초기 이미지나 프레임으로 채워진다.
2. 버퍼가 표시되는 동안 두번째 버퍼가 새 데이터나 이미지로 업데이트 된다.
3. 두번째 버퍼가 준비되면 첫번째 버퍼로 전환되어 화면에 표시된다.
4. 1,2번 버퍼가 일정간격으로 전환되어 최종 이미지 동영상 표시 프로세스가 계속된다.

더블 버퍼링을 사용하면 최종 이미지나 동영상이 중단이나 지연없이 표시되므로 깜빡임 및 기타 시각적 잔상이 줄어든다.

파이버 재조정 = 더블 버퍼링과 비슷하다

업데이트 발생 => 파이버 트리 fork => 사용자 인터페이스의 새로운 상태를 반영하도록 업데이트 ( 렌더링 )

현재 트리를 대체할 준비가 되고 사용자가 기대하는 상태를 정확하게 반영하면, 더블 버퍼링에서 비디오 버퍼를 교체하는 것처럼 현재 파이버 트리와 교체된다.

재조정의 커밋 단계 또는 커밋

화면에 표시되지 않는 작업용 트리를 사용하면 장점

- 살제 돔에 불필요한 업데이트 피할 수 있어 성능 개선 깜빡임 줄임
- 화면 밖에서 UI 새 상태를 계산, 우선순위가 더 높은 새로운 업데이트가 필요한 경우 이를 버릴 수 있다.
- 재조정은 화면 밖에서 이뤄지므로 사용자 현재 보고 잇는 내용을 망치지 않고 일시 중지했다 다시 시작할 수 있다.

JSX엘리먼트의 사용자 정의 트리에서 두가지 트리가 만들어진다.
현재 파이버를 포함하는 트리 + 작업용 파이버를 포함하는 트리

#### 파이버 재조정

렌더링 단계 => 커밋 단계
이 두단계 덕분에 리액트는 렌더링 작업을 수행하고 이를 돔에 커밋해서 사용자에게 보여주기 전 언제든지 폐기 할 수 있다.

렌더링 중단이 가능 = 가능한 듯 보이는 이유는 리액트 스케줄러가 5밀리초마다 실행을 메인스레드로 돌려주기 때문이다.

5밀리초는 초당 120프레임을 표현하는 기기에서 프레임 하나보다 짦은 시간이다.

workLoop | beginWork, completeWork | commitRoot
| 렌더링 단계 | 커밋 단계

스케줄러, 동시성 기능과 함께 다를 예정

#### 렌더링 단계

현재 트리에서 상태 변경 이벤트가 발생하면 시작, 리액트는 각 파이버를 재귀적, 단계적으로 순회하고 업데이트가 보류 중이라는 신호 플래그를 설정 대체 트리에 오프스크린 변경 작업을 수행

##### beginWork(작업시작)

작업용 트리에 있는 파이버 노드의 업데이트 필요 여부를 나타내는 플래그를 설정
여러 플래그를 설정하고 계속 다음 파이버 노드로 이동하면서 트리 맨 아래 도달할 때까지 동일한 작업을 수행한다.

이 작업이 완료되면 파이버 노드에서 completeWork 를 호출하고 다시 거슬러 올라가면서 순회한다.

beginWork 의 시그니처이다.

function beginWork(current, workInProgress, renderLanes)

current
업데이트 중인 작업용 노드에 해당하는 현재 트리 파이버노드에 대한 참조
트리의 이전 버전과 새 버전간에 변경된 사항과 업데이트할 사항을 결정하는 데 사용
불변하는 값이며 비교용으로만 사용된다.

workInProgress
작업용 트리에서 업데이트 중인 파이버 노드이다. beginWork 함수에 의해 업데이트 되어
'더티'로 표시된 채 반환되는 노드이다.

renderLanes
렌더 레인은 리액트 파이버 재조정자에서 기존의 renderExpirationTime 을 대체하는 새로운 개념
리액트가 업데이트 우선순위를 더 잘 정하고 업데이트 프로세스를 더 효율적으로 만들 수 있다.
업데이트가 처리되는 레인을 나타내는 비트마스크이다.
레인은 우선순위를 비롯해 여러 기준에 따라 업데이트를 분류하는 방식이다.
리액트 컴포넌트를 변경하면 우선순위를 비롯한 여러 특성에 따라 레인이 할당된다.

업데이트가 올바른 순서대로 처리되도록 하기 위해 renderLanes 가 beginWork 함수에 전달된다. 우선순위가 높은 레인에 할당된 업데이트는 낮은 레인에 할당된 업데이트보다 먼제 처리 된다.

사용자 상호작용이나 접근성에 영향을 미치는 업데이트 처럼 우선순위가 높은 업데이트가 최우선적으로 처리됩니다.

업데이트 우선순위를 지정하는 것 외에 다른 역할, renderLanes 는 리액트가 동시성을 더 잘 관리하도록 지원한다.

리액트 타임 슬라이싱 기술 사용해 실행시간이 긴 업데이트를 더 작고 관리하기 쉬운 덩어리로 분할 합니다. 이 과정에서 renderLanes 가 주된 역할을 한다.
리액트가 어떤 업데이트를 먼저 처리할지 어떤 업데이트를 미룰지 결정하기 때문

렌더링 단계가 완료되면 getLanesToRetry 함수가 호출되어 렌더링 단계 도중에 미뤄진 업데이트가 있는지 확인한다.

미뤄진 업데이트가 있는 경우 updateComponent 함수는 새로운 작업 루프를 시작하고
beginWork 와 getNextLanes 를 사용해 업데이트를 처리하며 레인에 따라 우선순위를 지정한다.

##### completeWork(작업 완료)

completeWork 함수는 작업용 파이버 노드에 업데이트를 적용하고 업데이트된 상태를 나타내는 실제 돔 트리를 새롭게 생성한다.

돔에서 분리된 트리를 브라우저가 시각적으로 표현하는 영역 바깥에 구성한다.

호스트 환경이 브라우저라면 createElemet, appendChild 같은 작업을 수행한다.
이 엘리먼트 트리가 아직 브라우저 내 문서에 추가되지 않은 상태인 것에 유의한다.

리액트는 화면 밖에서 다음에 보여 줄 UI 를 만들었을 뿐이다.
화면 밖에서 이 작업을 수행하면 중단 할 수 있다.

리액트가 계산하는 다음 상태는 아직 화면에 그려지지 않았기 때문에 만약 우선순위가 더 높은 업데이트가 예약되면 버려질 수 있다.

파이버 재조정자의 핵심

function completeWork(current, workInProgress, renderLanes)

시그니처는 beginWork 와 동일

beginWork 가 파이버 노드에 업데이트 필요 상태 플래그를 설정하는 역할
completeWork 는 호스트환경에 커밋할 새 트리를 구성하는 역할

completeWork 는 호스트 환경에 커밋할 새 트리를 구성하는 역할을 한다.
트리 맨 위에 도달해 새 돔 트리를 구성하면 렌더링 단계가 완료 되었다.고 불 수 있다.

커밋 단계로 넘어간다.

#### 커밋 단계

렌더링 단계에서 가상 돔에 적용된 변경사항을 실제 돔에 반영한다.
커밋 단계에서는 새 가상 돔 트리가 호스트 환경에 커밋되고 작업용 트리가 현재 트리로 바뀐다.

효과도 모두 실행된다( 바로 이어 나타난다? )

##### 변형 단계 ( mutation phase )

커밋 첫 부분 가상 돔에 적용된 변경사항을 실제 돔에 반영한다.
렌더링 단계에서 작업용 트리의 파이버 노드에 적용된 업데이트를 실제 돔에 반영한다.
더이상 필요하지 않는 노드를 돔에서 제거하기도 한다.

tag 별로 노드 업데이트

##### 레이아웃 단계

커밋 두번째 부분
돔에서 업데이트된 노드의 새 레이아웃을 계산한다.
업데이트되는 노드의 종류에 따라 함수를 호출하는 커다란 스위치 문장으로 이뤄짐.

레이아웃 단계가 완료되면 리액트는 렌더링 단계에서 가상돔에 적용되었던 변경사항을
실제 돔에 성공적으로 반영하게 된다.

리액트는 커밋 단계를 변현, 레이아웃 단계로 나눠 돔을 효율적으로 적용한다.
커밋 단계는 재조정자의 주요 기능과 함께 동작해서 더 복잡해지고 더 많은 데이터를 처리하지만 리액트 가 더 빠르고 응답성, 안정성이 좋아지도록 도와준다.

##### 효과 (effect)

커밋 단계에서는 여러 effect 이 특정 순서로 실행되며 그 순서는 효과 종류 따라 달라진다.

##### 배치

- 새 컴포넌트가 돔에 추가될때 발생 폼에 새 버튼이 추가되면 배치 효과가 발생해 해당 버튼이 돔에 추가된다.

##### 업데이트 효과

- 컴포넌트가 새로운 프롭이나 상태로 업데이트 될 때 발생한다.
  버튼의 텍스트가 변경되면 업데이트 효과가 발생해 돔의 텍스트가 업데이트 된다.

##### 삭제

- 컴포넌트가 돔에서 제거될때 발생한다. 폼에서 버튼이 제거되면 삭제 효과가 발생해 돔이 버튼이 제거

##### 레이아웃 효과

- 브라우저 페인트 가능 시점 전에 발생 페이지 레이아웃을 업데이트 하는데 사용
  함수 컴포넌트에서는 useLayoutEffect 수명 주기 메서드를 통해 관리한다.

이 같은 커밋 단계의 효과와 달리 패시브 효과는 브라우저 페인트 가능 시점 후에 실행되도록 예약된 사용자 정의 효과이며 useEffect 훅을 통해 관리된다.

패시브 효과는 API 에서 데이터 요청이나 분석 추적처럼 페이지의 초기 렌더링에 중요하지 않은 작업을 수행하는 데 유용하다.
패시브 효과는 렌더링 단계에서 수행되지 않으므로 사용자 인터페이스를 개발자가 원하는 상태로 만드는 데 필요한 최소 업데이트 집합의 계산 시간에 영향을 주지 않는다.

#### 화면에 모두 표시하기

현재 트리, 작업용 트리 중 하나 위에 FiberRootNode 를 둔다.
재조정 과정의 커밋단계를 관리하는 핵심 데이터 구조다.

가상 돔이 업데이트 되면 리액트는 현재 트리를 변경하지 않은 채 작업용 트리를 업데이트 한다. 이를 통해 현재 상태를 유지하면서 가상 돔을 계속 렌더링하고 업데이트 할 수 있다.

렌더링 프로세스가 완료되면 리액트는 commitRoot 함수를 호출해 작업용 트리에 적용된 변경 사항을 실제 돔에 커밋한다.

commitRoot 는 FiberRootNode 의 포인터를 현재 트리에서 작업용 트리로 전환
작업용 트리를 새로운 현재 트리로 만든다.

커밋 단계 이후 모든 업데이트는 새로운 현재 트리를 기반으로 이뤄진다.
