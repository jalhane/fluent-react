# 4.1 재조정 이해하기

- 이전 가상돔과 새로운 가상돔을 비교하여 변경이 필요한 부분을 찾는 과정
- 리액트는 실제 DOM 업데이트를 일괄 처리하고, 가능한 한 DOM을 적게 건드리는 방식으로 업데이트를 수행.

# 4.2 일괄 처리

- 여러 변경 사항을 DOM 문서에 일괄로 반영하여 단 한 번의 Reflow와 Repaint가 발생

```tsx
import { useState } from "react";

function Example() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount((prev) => prev + 1);
    setCount((prev) => prev + 1);
    setCount((prev) => prev + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

- 일괄 처리를 하지 않으면 실제돔은 세 번 업데이트한다.
- 리액트는 일괄 처리를 하기 때문에 돔을 한 번만 업데이트한다.
- `count + 3`을 하는 것이 아니라 `count + 1`을 세 번 하는 데 그 결과(`3`)을 한번 업데이트하는 것이 아닌가?

# 4.3 기존 기술

- 리액트 16버전 미만 버전에서는 스택 재조정자를 사용함. (LIFO)
- 작업을 순차적으로 변경 사항을 렌더링함.
  - 계산 비용이 비싼 작업이 선행되면 렉이 걸린다거나 UX에 영향이 감.
- 스택 재조정자는 업데이트의 우선순위를 정하지않음.
  - 비교적 덜 중요한 업데이트가 중요한 업데이트를 방해할 수 있음.
- 업데이트를 중단하거나 취소할 수 없다.

# 4.4 파이버 재조정자

- 조정자를 위한 작업 단위를 나타내는 파이버라는 데이터 구조가 사용됨.
- 파이버는 상태를 저장하고 수명이 길다. 리액트 엘리먼트는 임시적으로 상태가 없다.

## 4.4.1 데이터 구조로서의 파이버

- 파이버 노드의 각 인스턴스에는 해당 컴포넌트에 대한 프롭, 상태, 하위 컴포넌트 등이 포함.
- 컴포넌트 트리에서의 위치 정보, 업데이트 우선순위를 정하는 메타데이터들도 포함.

```tsx
// 파이버 노드 예시
{
  tag: 3,
  type: App,
  key: null,
  ref: null,
  props: {
    name: "John",
    age: 20,
  },
  stateNode: AppInstance,
  return: FiberParent,
  child: FiberChild,
  sibling: FiberSibling,
  index: 0,
  // ...
}
```

- tag: 각 컴포넌트 유형(클래스 컴포넌트, 함수 컴포넌트, 서스펜스, 에러 바운더리 등)에는 고유한 숫자 ID가 파이버로 설정됨.
- type: App은 이 파이버가 나타내는 함수 또는 클래스 컴포넌트를 나타낸다.
- props: 컴포넌트에 대한 입력 프롭 또는 함수에 대한 입력 인수
- stateNode: 파이버가 나타내는 App 컴포넌트의 인스턴스. 컴포넌트 트리에서의 위치는 return, child, sibling, index로 표현되는데 각각 부모, 자녀, 형제, 파이버의 색인을 의미하며, 파이버 재조저장는 이를 사용해 트리를 순회함.

### 재조정

- `createFiberFromTypeAndProps` 함수를 통해 가상돔의 각 리액트 엘리먼트에 대해 파이버 노드를 생성한다.
- 파이버 노드가 생성되면 파이버 재조정자는 작업 루프를 사용해 사용자 인터페이스를 업데이트한다.
- **beginWork: 루트 파이버 노드에서 시작해 컴포넌트 트리를 따라 내려가면서 업데이트가 필요한 경우 각 파이버 노드를 ‘더티’로 표시한다.**
- **completeWork**: 다시 위로 이동하며 브라우제에서 분리된 실제 돔 엘리먼트의 트리를 메모리로 구성한다.
- 오프스크린 렌더링 프로세스으로 언제든지 중단하고 버릴 수 있다.

### 렌더링

- 업데이트가 발생하면 현재 파이버 트리가 포크되어 주어진 사용자 인터페이스의 새로운 상태를 반영하도록 업데이트 된다. → 사용자 인터페이스라는 말이 너무 애매한 것 같다.

### 커밋

- 그 후 트리를 대체할 트리가 준비되고 사용자가 기대하는 상태를 정확하게 반영하면 현재 파이버 트리와 교체된다.

내가 생각하는 것

1. 업데이트가 발생
2. 현재 상태를 나타내는 current 트리를 복사하여 workInProgress 트리를 생성 (포크)
3. workInProgress에 업데이트된 상태를 반영하고 current 트리와 비교 (재조정)
4. 실제 DOM에 적용 (커밋)

## 렌더링

### beginWork

- workInProgress 트리에 있는 파이버 노드의 업데이트 필요 여부를 나타내는 플래그(더티)를 설정

```tsx
function BeginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lane
): Fiber | null;
```

- current: 현재 트리의 파이버 노드에 대한 참조. 비교용으로만 사용됨.
- workInProgress: beginWork 함수에 의해 업데이트되어 ‘더티’로 표시된 채 반환되는 노드
- renderLanes: 업데이트 우선순위를 정함. 변경의 우선순위가 높을수록 더 높은 레인이 할당.

### completeWork

- workInProgress 파이버 노드에 업데이트를 적용하고 애플리케이션의 업데이트 된 상태를 나타내는 실제 DOM 트리를 새롭게 생성. UI를 만들었을 뿐 화면에 보이지않음.

```jsx
function completeWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes
): Fiber | null;
```

## 커밋

- 가상 DOM에 적용된 변경 사항을 실제 DOM에 반영

### 변형 단계

- workInProgress의 파이버 노드에 적용된 업데이트를 실제 DOM에 반영
- `commitMutationEffects` 함수 호출
  - DOM을 직접적으로 수정하는 모든 작업이 여기서 이루어진다.

### 레이아웃 단계

- DOM에 업데이트된 노드의 새 레이아웃을 계산한다.
- `commitLayoutEffects` 함수 호출
  - DOM 변경이 모두 완료된 직후, 브라우저가 화면을 그리기(paint) 전에 실행되는 함수. 이 함수는 주로 화면에 DOM 요소가 배치된 후 그 크기나 위치를 측정하고, 그에 따라 동기적으로 무언가를 처리해야 할 때 사용되는 효과(effect)들을 실행

### 효과

- 커밋 단계에서 여러 부작용이 특정 순서로 실행됨

1. 배치 효과 - 새 컴포넌트가 DOM에 추가될 때 발생
2. 업데이트 효과 - 새로운 프롭이나 상태가 업데이트될 때 발생
3. 삭제 효과 - 컴포넌트가 DOM에서 제거될 때 발생
4. 레이아웃 효과 - 브라우저 페인트 기능 시점 전에 발생하며 페이지 레이아웃을 업데이트하는 데 사용(useLayoutEffect)
