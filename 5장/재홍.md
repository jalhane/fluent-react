# 5.1 React.memo를 사용한 메모화

- **입력을 기준**으로 함수의 출력을 저장해 뒀다가 동일한 입력이 들어오면 연산을 수행하지 않고 캐싱된 출력을 반환.
  - 메모화를 하려면 그 함수는 무조건 **순수**해야한다.
- React.memo는 props의 얕은 비교를 수행하여 변경여부를 확인함.
  - 그래서 참조 타입을 props으로 받을 때 주의해야 한다.

# 5.2 useMemo를 사용한 메모화

- 컴포넌트 내부의 특정 계산으 메모화해 비용이 많이 드는 재계산을 피하고 결과에 대한 일관된 참조유지

```tsx
export default function App({ unsortedPeople }) {
  const [count, setCount] = useState(0);
  const sortedPeople = useMemo(
    () => [...unsortedPeople].sort((a, b) => b.age - a.age),
    [unsortedPeople]
  );

  return <div></div>;
}
```

- useMemo를 사용하지 않으면 count가 변할 때마다 컴포넌트가 리렌더링하여 sort 연산도 다시 수행하게 됨. → sort는 성능이 좋지않음
- useMemo로 감싸 unsortedPeople이 변할 때만 sort 연산이 수행되도록 수정
- 이때 원본 배열을 복사해서 원본 배열이 변경되지 않도록 해야함.

## useMemo의 나쁜 사례

- 원시 타입의 값은 useMemo를 사용할 필요가 없다. 원시 타입은 메모리 참조가 아니라 그 값 자체를 비교하기 때문에 useMemo 함수를 읽고 실행하는 작업이 최적화하려는 실제 작업보다 비용이 더 많이 들 수 있다.

```tsx
import { useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);
  const handleClick = () => {
    setCount((prev) => prev + 1);
  };

  return (
    <div>
      <div>{count}</div>
      <button onClick={handleClick}>Increment</button>
    </div>
  );
}
```

- 이 때 onClick의 콜백함수도 메모화할 필요가 없다.

## 내장 컴포넌트 (호스트 컴포넌트)

- 내장 컴포넌트(div, button, input 등)는 함수props를 사용자 정의 컴포넌트와는 다르게 취급한다.

1. 직접 전달
   - 함수 props를 내장 컴포넌트에 전달하면 실제 DOM 엘리먼트에 직접 전달한다. 래퍼 생성과 같은 추가 작업을 하지 않음.
   - onXXX와 같은 이벤트 기반 props의 경우 DOM 노드에 직접 추가하지 않고 문서 root에 첨부되어 이벤트 버블링을 사용해 개별 엘리먼트에서 발생하는 이번트를 포착한다.
2. 렌더링 동작
   - 내장 컴포넌트는 리렌더링된 상위 컴포넌트 일부가 아니면 함수 props 변경에 의해 리렌더링 되지 않는다.
   - 예시에서 handleClick 시 컴포넌트가 리렌더링 되어 새로운 handleClick(함수 props)가 만들어지지만(변경되지만) 그냥 DOM 업데이트일 뿐, 우리 눈에 보이거나 콘솔에 찍히는 리렌더링은 없다.
3. 함수에 대한 가상 DOM 비교하지 않음
   - 위와 같은 내용인 듯.

## useCallback의 좋은 사용 사례

- 자주 리렌더링할 가능성이 있는 컴포넌트가 있고 하위 컴포넌트에 콜백을 전달할 때, 특히 하위 컴포넌트가 React.memo로 최적화된 경우 유용하다.

```jsx
import React, { useState, useCallback } from 'react';

// React.memo로 최적화된 자식 컴포넌트
const MemoizedChild = React.memo(({ onButtonClick, label }) => {
  console.log(`${label}가 렌더링되었습니다!`);
  return <button onClick={onButtonClick}>{label}</button>;
});

// 부모 컴포넌트
export default function ParentComponent() {
  const [unrelatedCounter, setUnrelatedCounter] = useState(0);

  // 👎 일반 함수: ParentComponent가 리렌더링될 때마다 새로 생성됩니다.
  const handleClickWithoutCallback = () => {};

  // 👍 useCallback 사용: ParentComponent가 리렌더링 되어도 재생성되지 않습니다.
  const handleClickWithCallback = useCallback(() => {}, []);

  return (
    <div>
      <button onClick={() => setUnrelatedCounter(c => c + 1)}>
        부모 счёт기 증가 (리렌더링 유발)
      </button>
      <p>상관없는 счёт기: {unrelatedCounter}</p>
      <hr />

      <h3>1. useCallback 없는 경우 (비효율적) 👎</h3>
      <p>부모 счёт기를 누를 때마다 자식도 리렌더링됩니다.</p>
      <MemoizedChild
        label="Without useCallback"
        onButtonClick={handleClickWithoutCallback}
      />

      <hr />

      <h3>2. useCallback 사용한 경우 (효율적) 👍</h3>
      <p>부모 счёт기를 눌러도 자식은 리렌더링되지 않습니다.</p>
      <MemoizedChild
        label="With useCallback"
        onButtonClick={handleClickWithCallback}
      />
    </div>
  );
```

## React Forget

- 리액트 컴파일러에서 알아서 메모화를 자동으로 처리하여 useMemo, useCallback같은 걸 필요없게 만듦.

# 5.3 지연 로딩

- 코드 스플리팅: 특정 페이지나 기능에 필요한 자바스크립트만 읽어 들이는 방법

```tsx
import("./large.js").then((module) => {
  module.default();
});
```

- 지연 로딩: 페이지가 완전히 읽어 들여질 때까지 초기 실행에 필수적이지 않은 자바스크립트의 로딩을 미루는 것
- React.lazy와 Suspense를 사용하면 됨.

```jsx
import React, { useState, Suspense, lazy } from "react";

// Greeting 컴포넌트를 React.lazy를 사용해 동적으로 불러옵니다.
const LazyGreeting = lazy(() => import("./Greeting"));

function App() {
  const [show, setShow] = useState(false);

  return (
    <div>
      {/* 이 버튼을 누르면 LazyGreeting 컴포넌트가 로드됩니다. */}
      <button onClick={() => setShow(true)}>인사말 보기</button>
      <hr />

      {/* show가 true일 때만 컴포넌트를 렌더링합니다. */}
      {show && (
        // Suspense가 LazyGreeting의 로딩을 감지하고,
        // 로딩이 끝날 때까지 fallback UI를 보여줍니다.
        <Suspense fallback={<div>로딩 중...</div>}>
          <LazyGreeting />
        </Suspense>
      )}
    </div>
  );
}

export default App;
```

# 5.4 useState와 useReducer

- useState는 useReducer의 상위 추상화

# 5.5 강력한 패턴

디자인 패턴은 여러가지 이유로 중요하다.

- 재사용성, 표준화, 유지 보수성, 효율성

### 프레젠테이션/ 컨테이너 컴포넌트

- 프레젠테이션 컴포넌트: UI 렌더링
- 컨테이너 컴포넌트: UI 상태 처리
- 리액트 처음 배울 때 이 패턴을 좋아했지만 훅을 사용하는 것이 더 깔끔하고 더 좋아한다.

### 고차 컴포넌트

- 다른 컴포넌트를 인수로 새로운 컴포넌트를 반환하는 컴포넌트
- 여러 컴포넌트에서 공유하는 동작을 반복 작성하고 싶지 않을 때 유용
- 얘도 훅으로 하면 된다. 훅이 짱이다.

```jsx
// 🎁 HOC: 컴포넌트를 포장하는 함수
const withBorder = (OriginalComponent) => (props) => {
  // 포장된 새로운 컴포넌트를 만들어서 돌려줌
  return (
    <div style={{ border: "2px solid red", padding: "10px" }}>
      {/* 알맹이(원본 컴포넌트)는 그대로 보여줌 */}
      <OriginalComponent {...props} />
    </div>
  );
};

// 👕 꾸며줄 알맹이 컴포넌트
const Hello = () => {
  return <h1>안녕하세요!</h1>;
};

// ✨ HOC로 'Hello' 컴포넌트를 포장(꾸미기)
const HelloWithBorder = withBorder(Hello);

// 화면에 보여주기
function App() {
  return (
    <div>
      <h3>이것이 바로 포장된 컴포넌트입니다! 👇</h3>
      <HelloWithBorder />
    </div>
  );
}
```

### 렌더 프롭, 자식 함수

**렌더 프롭**은 "무엇을 렌더링할지"를 컴포넌트 자신이 결정하지 않고, 프롭**으로 전달받은 함수에게 맡기는** 디자인 패턴

자식 함수는 children을 사용해서 동일한 기능을 하는 패턴

```jsx
import React, { useState, useEffect } from "react";

// 'render' prop을 받아 호출하는 컴포넌트
function MousePosition({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  useEffect(() => {
    const handleMouseMove = (e) => setPosition({ x: e.clientX, y: e.clientY });
    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, []);

  // state를 인자로 넘겨주면서 props로 받은 render 함수를 호출한다.
  return render(position);
}

// 사용 예시
export default function App() {
  return (
    <div>
      <h2>Render Prop 예시 (render prop 사용)</h2>
      <MousePosition
        render={(mousePosition) => (
          <h1>
            마우스 위치: {mousePosition.x}, {mousePosition.y}
          </h1>
        )}
      />
    </div>
  );
}
```

### 제어 프롭

부모 컴포넌트가 자식 컴포넌트의 상태(state)를 완전히 통제하는 패턴

```jsx
import React, { useState } from "react";

// 자식 컴포넌트: 스스로의 상태가 없다.
// 부모가 주는 on(상태)과 onToggle(핸들러) 프롭에 전적으로 의존한다.
function Switch({ on, onToggle }) {
  return <button onClick={onToggle}>{on ? "켜짐" : "꺼짐"}</button>;
}

// 부모 컴포넌트: 모든 상태와 로직을 제어한다.
export default function App() {
  const [isOn, setIsOn] = useState(false); // 상태는 부모가 관리

  const handleToggle = () => {
    setIsOn((prevIsOn) => !prevIsOn); // 상태 변경 로직도 부모가 관리
  };

  return (
    <div>
      <h2>제어 프롭(Controlled Props) 예시</h2>
      {/* 자식에게 상태와 상태 변경 함수를 props로 내려준다. */}
      <Switch on={isOn} onToggle={handleToggle} />
      <p>현재 스위치 상태: {isOn ? "ON" : "OFF"}</p>
    </div>
  );
}
```

### 프롭 컬렉션, 프롭 게터

- 프롭 컬렉션: **프롭 컬렉션**은 props 묶음을 함수가 아닌, **미리 만들어진 객체(Object)** 형태로 제공하는 방식
- 프롭 게터: props 객체를 반환하는 함수를 제공하는 방식

```jsx
// 프롭 컬렉션 방식
function PropCollectionExample() {
  const [name, setName] = useState("");

  const someProps = {
    value: name,
    onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
      setName(e.target.value),
  };

  return (
    <div>
      <h3>프롭 컬렉션 방식</h3>
      <input {...someProps} />
    </div>
  );
}

// 프롭 게터 방식
function PropGetterExample() {
  const [name, setName] = useState("");
  const [email, setEmail] = useState("");

  const getInputProps = (field: string) => ({
    value: field === "name" ? name : email,
    onChange: (e: React.ChangeEvent<HTMLInputElement>) =>
      field === "name" ? setName(e.target.value) : setEmail(e.target.value),
  });

  return (
    <div>
      <h3>프롭 게터 방식</h3>
      <input {...getInputProps("name")} />
      <input {...getInputProps("email")} />
    </div>
  );
}
```

### 복합 컴포넌트

**하나의 특정 기능을 완성하기 위해 여러 개의 컴포넌트가 한 팀처럼 동작하며 암시적으로 상태를 공유하는** 디자인 패턴

- Radix UI 코드 보면 됨
- 일반적으로 react.context를 사용하여 구현.

```jsx
import { useState, createContext, useContext } from "react";

const ToggleContext = createContext<{
  isOn: boolean;
  toggle: () => void;
} | null>(null);

function Toggle({ children }: { children: React.ReactNode }) {
  const [isOn, setIsOn] = useState(false);
  const toggle = () => setIsOn(!isOn);

  return (
    <ToggleContext.Provider value={{ isOn, toggle }}>
      {children}
    </ToggleContext.Provider>
  );
}

function ToggleButton() {
  const context = useContext(ToggleContext);
  if (!context) throw new Error("ToggleButton must be used within Toggle");

  return (
    <button onClick={context.toggle}>{context.isOn ? "ON" : "OFF"}</button>
  );
}

function ToggleDisplay() {
  const context = useContext(ToggleContext);
  if (!context) throw new Error("ToggleDisplay must be used within Toggle");

  return <div>상태: {context.isOn ? "켜짐" : "꺼짐"}</div>;
}

// 자식들을 부모의 프로퍼티로 할당하여 API를 더 명확하게 만듦
Toggle.Button = ToggleButton;
Toggle.Display = ToggleDisplay;

export default function App() {
  return (
    <div>
      <h3>복합 컴포넌트 예시</h3>
      <Toggle>
        <Toggle.Display />
        <Toggle.Button />
      </Toggle>
    </div>
  );
}
```
