### 5장 자주 묻는 질문과 유용한 패턴

#### 5.1 React.memo를 사용한 메모화

**메모화란?**
메모화는 함수의 입력값에 따라 계산된 결과를 저장해두었다가, 같은 입력이 들어오면 다시 계산하지 않고 저장된 값을 반환하는 최적화 방법입니다.

**메모화가 효과적인 경우:**

- 순수 함수처럼 입력이 같으면 항상 같은 결과가 나오는 경우
- 예: 단순한 덧셈 함수, 수학 계산 함수

**메모화가 불가능한 경우:**

- 외부 API를 호출해 결과가 달라지는 함수
- 랜덤 값을 반환하는 함수
- 현재 시간을 반환하는 함수

**React.memo의 동작 원리:**

```javascript
// 기본 사용법
const MemoizedComponent = React.memo(MyComponent);

// 커스텀 비교 함수 사용
const MemoizedComponent = React.memo(MyComponent, (prevProps, nextProps) => {
  // true를 반환하면 리렌더링 안함 (props가 같음)
  // false를 반환하면 리렌더링 함 (props가 다름)
  return prevProps.name === nextProps.name && prevProps.age === nextProps.age;
});
```

**React.memo의 장점:**

1. **성능 향상**: 프롭이 변경되지 않으면 컴포넌트를 다시 호출하지 않음
2. **불필요한 렌더링 방지**: 중첩된 컴포넌트에서 변경된 컴포넌트만 리렌더링
3. **복잡한 구조 최적화**: 대시보드처럼 복잡한 구조에서 전체 성능 개선

**주의사항:**

- **얕은 비교**: React.memo는 프롭의 변경 여부를 얕은 비교로 판단
- **스칼라 타입**: 숫자, 문자열, 불리언은 정확하게 비교 가능
- **복합 타입**: 객체나 배열은 값이 같아도 참조가 다르면 변경된 것으로 인식

**실제 사용 예시:**

```javascript
// 부모 컴포넌트
function ParentComponent() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("홍길동");

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>카운트: {count}</button>
      <MemoizedChild name={name} />
    </div>
  );
}

// 메모화된 자식 컴포넌트
const MemoizedChild = React.memo(function ChildComponent({ name }) {
  console.log("ChildComponent 렌더링됨"); // name이 변경될 때만 출력
  return <div>안녕하세요, {name}님!</div>;
});
```

**참조 타입 프롭 최적화:**

```javascript
// 문제: 매번 새로운 객체/배열 생성
function Parent() {
  const [count, setCount] = useState(0);

  return (
    <Child
      data={{ name: "홍길동", age: 30 }} // 매번 새로운 객체
      items={[1, 2, 3]} // 매번 새로운 배열
    />
  );
}

// 해결: useMemo로 메모화
function Parent() {
  const [count, setCount] = useState(0);

  const data = useMemo(() => ({ name: "홍길동", age: 30 }), []);
  const items = useMemo(() => [1, 2, 3], []);

  return <Child data={data} items={items} />;
}
```

**useMemo와 useCallback 사용 가이드:**

**useMemo 사용 시기:**

- 계산 비용이 큰 작업 (정렬, 필터링, 복잡한 계산)
- 참조 안정성이 필요한 경우
- 의존성 배열의 값이 바뀔 때만 재계산이 필요한 경우

```javascript
// 좋은 예: 복잡한 계산
const expensiveValue = useMemo(() => {
  return items.sort((a, b) => a.priority - b.priority);
}, [items]);

// 나쁜 예: 단순한 값
const simpleValue = useMemo(() => count * 2, [count]); // 불필요
```

**useCallback 사용 시기:**

- React.memo로 감싸진 자식 컴포넌트에 함수를 전달할 때
- 의존성이 있는 함수를 메모화할 때

```javascript
// 좋은 예: 메모화된 자식 컴포넌트에 콜백 전달
const MemoizedChild = React.memo(ChildComponent);

function Parent() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((prev) => prev + 1);
  }, []);

  return <MemoizedChild onClick={handleClick} />;
}

// 나쁜 예: 내장 컴포넌트에 전달되는 함수
function Parent() {
  const handleClick = useCallback(() => {
    console.log("clicked");
  }, []); // 불필요

  return <button onClick={handleClick}>클릭</button>;
}
```

**성능 최적화 팁:**

1. **적절한 사용**: 모든 컴포넌트에 React.memo를 적용하지 말고, 실제로 불필요한 렌더링이 발생하는 컴포넌트에만 적용
2. **참조 동일성**: 객체나 함수를 props로 전달할 때는 useMemo, useCallback과 함께 사용
3. **비교 함수**: 복잡한 객체 비교가 필요한 경우 커스텀 비교 함수 제공
4. **측정 후 최적화**: 성능 문제가 실제로 발생하는지 확인한 후 최적화 적용

### 5.3 지연로딩 (Lazy Loading)

**지연로딩이란?**
웹 성능을 높이기 위해 필요한 시점에만 코드를 로드하는 기법입니다.

**왜 필요한가?**

- 자바스크립트 파일을 한 번에 모두 불러오면 페이지 로딩이 느려짐
- 데이터 사용량 증가
- 초기 로딩 속도와 사용자 경험 저하

**React.lazy와 Suspense 사용법:**

```javascript
import React, { Suspense, lazy } from "react";

// 컴포넌트를 지연 로딩으로 정의
const LazyComponent = lazy(() => import("./LazyComponent"));

function App() {
  return (
    <div>
      <h1>메인 페이지</h1>
      <Suspense fallback={<div>로딩 중...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}
```

**Suspense의 특징:**

- 비동기로 로드되는 컴포넌트가 준비될 때까지 폴백 UI 표시
- 컴포넌트 트리 어디든 배치 가능
- 필요한 부분만 감싸서 UI 응답성 향상

**실제 사용 예시:**

```javascript
// 모달 컴포넌트 지연 로딩
const Modal = lazy(() => import("./Modal"));

function App() {
  const [showModal, setShowModal] = useState(false);

  return (
    <div>
      <button onClick={() => setShowModal(true)}>모달 열기</button>

      {showModal && (
        <Suspense fallback={<div>모달 로딩 중...</div>}>
          <Modal onClose={() => setShowModal(false)} />
        </Suspense>
      )}
    </div>
  );
}
```

**최적화 팁:**

1. **세밀한 분할**: 전체 앱을 감싸지 말고 필요한 컴포넌트만 감싸기
2. **적절한 폴백**: 로딩 상태에 맞는 UI 제공 (스켈레톤, 스피너 등)
3. **사전 로딩**: 사용자가 클릭할 가능성이 높은 컴포넌트는 미리 로드

### 5.4 useState와 useReducer

**언제 어떤 것을 사용할까?**

| 상황                    | 사용할 훅    | 이유                      |
| ----------------------- | ------------ | ------------------------- |
| 단일 값, 간단한 객체    | `useState`   | 간단하고 직관적           |
| 복잡한 상태 로직        | `useReducer` | 안전하고 명확한 상태 관리 |
| 여러 상태가 연관됨      | `useReducer` | 상태 업데이트 로직 통합   |
| 상태 변경 패턴이 복잡함 | `useReducer` | 액션 기반 상태 관리       |

**useState 사용 예시:**

```javascript
function Counter() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState("");

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>

      <input
        value={name}
        onChange={(e) => setName(e.target.value)}
        placeholder="이름 입력"
      />
    </div>
  );
}
```

**useReducer 사용 예시:**

```javascript
// Reducer 함수 (컴포넌트 외부)
function todoReducer(state, action) {
  switch (action.type) {
    case "ADD_TODO":
      return [...state, { id: Date.now(), text: action.text, done: false }];
    case "TOGGLE_TODO":
      return state.map((todo) =>
        todo.id === action.id ? { ...todo, done: !todo.done } : todo
      );
    case "DELETE_TODO":
      return state.filter((todo) => todo.id !== action.id);
    default:
      return state;
  }
}

function TodoApp() {
  const [todos, dispatch] = useReducer(todoReducer, []);

  return (
    <div>
      <button onClick={() => dispatch({ type: "ADD_TODO", text: "새 할일" })}>
        할일 추가
      </button>
      {todos.map((todo) => (
        <div key={todo.id}>
          <span>{todo.text}</span>
          <button
            onClick={() => dispatch({ type: "TOGGLE_TODO", id: todo.id })}
          >
            {todo.done ? "완료" : "미완료"}
          </button>
        </div>
      ))}
    </div>
  );
}
```

**useReducer의 장점:**

1. **로직 분리**: 상태 업데이트 로직을 컴포넌트 밖으로 분리
2. **테스트 용이**: reducer 함수를 독립적으로 테스트 가능
3. **재사용성**: 여러 컴포넌트에서 같은 reducer 사용 가능
4. **명시적 관리**: 상태 변경이 액션으로 명확하게 표현됨
5. **고급 패턴**: 시간 여행 디버깅, 실행 취소 등 구현 가능

**Immer로 복잡한 상태 관리 단순화:**

```javascript
import { produce } from "immer";

function ComplexState() {
  const [state, setState] = useState({
    user: {
      name: "홍길동",
      profile: {
        age: 30,
        address: {
          city: "서울",
          district: "강남구",
        },
      },
    },
    posts: [],
  });

  // Immer 없이 (복잡함)
  const updateAddress = (newCity) => {
    setState((prevState) => ({
      ...prevState,
      user: {
        ...prevState.user,
        profile: {
          ...prevState.user.profile,
          address: {
            ...prevState.user.profile.address,
            city: newCity,
          },
        },
      },
    }));
  };

  // Immer 사용 (간단함)
  const updateAddressWithImmer = (newCity) => {
    setState(
      produce((draft) => {
        draft.user.profile.address.city = newCity;
      })
    );
  };

  return (
    <div>
      <p>도시: {state.user.profile.address.city}</p>
      <button onClick={() => updateAddressWithImmer("부산")}>도시 변경</button>
    </div>
  );
}
```

**선택 가이드:**

- **useState**: 단순한 상태, 빠른 프로토타이핑
- **useReducer**: 복잡한 상태 로직, 상태 변경 패턴이 많음
- **Immer**: 중첩된 객체 상태 관리가 복잡할 때

### 5.5 강력한 패턴

#### 5.5.1 프레젠테이션/컨테이너 패턴

**개념:**
UI와 상태 관리를 분리하여 코드의 재사용성과 테스트성을 높이는 패턴입니다.

**구조:**

- **프레젠테이션 컴포넌트**: UI만 렌더링 (props를 받아서 표시)
- **컨테이너 컴포넌트**: 상태와 로직 관리 (데이터 가져오기, 상태 업데이트)

```javascript
// 프레젠테이션 컴포넌트 (UI만 담당)
function UserList({ users, loading, error }) {
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>오류 발생: {error}</div>;

  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// 컨테이너 컴포넌트 (로직 담당)
function UserListContainer() {
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    fetchUsers()
      .then(setUsers)
      .catch(setError)
      .finally(() => setLoading(false));
  }, []);

  return <UserList users={users} loading={loading} error={error} />;
}
```

**장점:**

- 단일 책임 원칙 준수
- 컴포넌트 재사용성 향상
- 테스트 용이성 (UI와 로직 분리)
- 코드 가독성 향상

#### 5.5.2 고차 컴포넌트 (HOC)

**개념:**
컴포넌트를 받아서 새로운 컴포넌트를 반환하는 함수로, 공통 로직을 재사용할 수 있게 해줍니다.

**기본 구조:**

```javascript
function withHOC(WrappedComponent) {
  return function EnhancedComponent(props) {
    // 공통 로직
    return <WrappedComponent {...props} />;
  };
}
```

**실제 예시 - withAsync HOC:**

```javascript
// 비동기 데이터 처리를 위한 HOC
function withAsync(WrappedComponent) {
  return function AsyncComponent({ fetchData, ...props }) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);

    useEffect(() => {
      fetchData()
        .then(setData)
        .catch(setError)
        .finally(() => setLoading(false));
    }, [fetchData]);

    return (
      <WrappedComponent
        {...props}
        data={data}
        loading={loading}
        error={error}
      />
    );
  };
}

// 사용 예시
const BlogPost = ({ title, content, loading, error }) => {
  if (loading) return <div>로딩 중...</div>;
  if (error) return <div>오류: {error}</div>;

  return (
    <article>
      <h1>{title}</h1>
      <p>{content}</p>
    </article>
  );
};

const AsyncBlogPost = withAsync(BlogPost);

// 사용
<AsyncBlogPost fetchData={() => fetchBlogPost(id)} />;
```

**HOC 합성:**

```javascript
// compose 함수
const compose =
  (...fns) =>
  (x) =>
    fns.reduceRight((acc, fn) => fn(acc), x);

// 여러 HOC 합성
const EnhancedComponent = compose(
  withAsync,
  withAuth,
  withLogging
)(MyComponent);

// 또는 중첩 사용
const EnhancedComponent = withAsync(withAuth(withLogging(MyComponent)));
```

**HOC vs 훅 비교:**

- **HOC**: 렌더링 제어 가능, 프롭 조작 가능, '래퍼 지옥' 위험
- **훅**: 더 직관적, 테스트 용이, 타입 안전성 우수

**현재 상황:**
최근에는 훅이 더 편리해서 HOC보다 자주 사용되지만, 특정 상황에서는 여전히 유용합니다.

### 5.6 HOC vs 훅 비교

**HOC와 훅의 주요 차이점:**

| 특징                    | HOC                                                     | 훅                                                                            |
| ----------------------- | ------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **코드 재사용**         | 여러 컴포넌트 간 로직 공유에 탁월                       | 컴포넌트 내부 또는 유사 컴포넌트 간 로직 추출 및 공유에 이상적                |
| **렌더링/프롭 조작**    | 렌더링을 제어하고 프롭을 조작 가능                      | 렌더링에 직접 영향을 주지 않으며 프롭을 조작할 수 없음                        |
| **상태/수명 주기 관리** | 감싸진 컴포넌트 외부에서 상태와 수명 주기 로직을 캡슐화 | 함수 컴포넌트 내에서 로컬 상태를 관리하고 useEffect로 수명 주기 이벤트를 처리 |
| **합성/테스트 용이성**  | 잘못 관리하면 '래퍼 지옥'으로 이어질 수 있음            | 합성이 쉽고 테스트하기 용이                                                   |
| **타입 안전성**         | 타입스크립트와 함께 사용할 때 복잡할 수 있음            | 타입스크립트와 함께 사용할 때 타입 추론이 향상되어 타입 안전성이 더 좋음      |

**HOC의 장점:**

- 감싸진 컴포넌트의 렌더링 제어 및 프롭 조작에 능숙
- 대규모 코드베이스에서 유용
- 훅을 채택하지 않은 프로젝트에서 효과적

**HOC의 단점:**

- 과도한 중첩은 '래퍼 지옥'을 유발
- 테스트 및 타입 안전성을 복잡하게 만들 수 있음

**훅의 장점:**

- 컴포넌트 레이어를 추가하지 않고 로직을 추출하여 '래퍼 지옥'을 피할 수 있음
- 함수 컴포넌트 내에서 상태, 수명 주기, 기타 React 기능을 직접적이고 덜 복잡하게 관리
- 합성과 테스트가 용이

**React의 내장 HOC 예시:**

```javascript
// React.memo - 메모화 HOC
const MemoizedComponent = React.memo(MyComponent);

// React.forwardRef - ref 전달 HOC
const FancyInput = React.forwardRef((props, ref) => (
  <input ref={ref} className="fancy-input" {...props} />
));

// 사용 예시
function App() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  return <FancyInput ref={inputRef} placeholder="포커스가 자동으로 됩니다" />;
}
```

**선택 기준:**
두 기술 모두 로직 재사용 메커니즘을 제공하지만, 프로젝트의 요구 사항과 패턴에 대한 친숙도에 따라 적절한 것을 선택해야 합니다. HOC는 대규모 코드베이스나 훅을 채택하지 않은 경우에 유용할 수 있습니다.

### 5.7 고급 React 패턴들

#### 5.7.1 React.forwardRef

`React.forwardRef`는 부모 컴포넌트가 자식 컴포넌트의 DOM 엘리먼트에 직접 접근할 수 있도록 하는 패턴입니다.

```javascript
// forwardRef를 사용한 컴포넌트
const FancyInput = React.forwardRef((props, ref) => (
  <input ref={ref} className="fancy-input" {...props} />
));

// 사용 예시
function App() {
  const inputRef = useRef(null);

  useEffect(() => {
    inputRef.current?.focus();
  }, []);

  return <FancyInput ref={inputRef} placeholder="포커스가 자동으로 됩니다" />;
}
```

**특징:**

- HOC로 해결하기 어려운 ref 전달 문제를 해결
- 부모 컴포넌트가 자식의 DOM 메서드(focus, blur 등)에 직접 접근 가능
- 고차 컴포넌트의 좋은 대안

#### 5.7.2 렌더 프롭 (Render Props)

렌더 프롭은 컴포넌트의 상태를 전달받는 함수를 프롭으로 사용하는 패턴으로, 코드 재사용성을 높입니다.

```javascript
// WindowSize 컴포넌트 (헤드리스 컴포넌트)
const WindowSize = (props) => {
  const [size, setSize] = useState({ width: -1, height: -1 });

  useEffect(() => {
    const handleResize = () => {
      setSize({ width: window.innerWidth, height: window.innerHeight });
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  return props.render(size);
};

// 사용 예시
<WindowSize
  render={({ width, height }) => (
    <div>
      창 크기: {width}x{height}px
    </div>
  )}
/>;
```

**특징:**

- 컴포넌트 자체는 UI를 렌더링하지 않는 "헤드리스" 컴포넌트
- 제어의 역전(Inversion of Control)을 통해 렌더링 작업을 부모에 위임
- DRY 원칙을 지키며 로직 재사용 가능
- **현재 상태**: React Hooks로 대체되어 더 이상 널리 사용되지 않음

#### 5.7.3 자식 함수 (Children as a Function)

렌더 프롭의 변형으로, `render` 프롭 대신 `children` 프롭을 함수로 사용하는 방식입니다.

```javascript
// children을 함수로 사용
<WindowSize>
  {({ width, height }) => (
    <div>
      창 크기: {width}x{height}px
    </div>
  )}
</WindowSize>
```

**특징:**

- 일부 개발자들은 이 방식이 코드의 의도에 더 충실하다고 봄
- `WindowSize`가 React Context와 비슷하게 느껴짐
- **현재 상태**: React Hooks로 인해 더 이상 사용되지 않음

#### 5.7.4 제어 프롭 (Controlled Props)

제어 프롭은 React의 "제어 컴포넌트" 개념을 확장한 상태 관리 전략입니다.

**제어 컴포넌트란:**

- 자체 내부 상태를 유지하지 않는 컴포넌트
- 부모 컴포넌트의 프롭에 의해 값이 결정됨
- 상태 변경 시 부모에게 콜백으로 알림

```javascript
// 기본 제어 컴포넌트 예시
function Form() {
  const [inputValue, setInputValue] = useState("");

  function handleChange(event) {
    setInputValue(event.target.value);
  }

  return <input type="text" value={inputValue} onChange={handleChange} />;
}
```

**제어/비제어 토글 버튼 예시:**

```javascript
function Toggle({ on, onToggle }) {
  const [isOn, setIsOn] = useState(false);

  const handleToggle = () => {
    const nextState = on === undefined ? !isOn : on;

    if (on === undefined) {
      setIsOn(nextState);
    }
    if (onToggle) {
      onToggle(nextState);
    }
  };

  return (
    <button onClick={handleToggle}>
      {on !== undefined ? on : isOn ? "On" : "Off"}
    </button>
  );
}
```

**특징:**

- `isOn`: 내부 상태
- `on`: 외부 제어 프롭
- `onToggle`: 부모에게 상태 변경을 알리는 콜백
- 제어 모드와 비제어 모드를 모두 지원하여 유연성 제공

#### 5.7.5 프롭 컬렉션 (Prop Collections)

관련된 프롭들을 객체로 묶어 재사용성을 높이는 패턴입니다.

```javascript
// 드래그 앤 드롭 프롭 컬렉션
export const droppableProps = {
  onDragOver: (event) => {
    event.preventDefault();
  },
  onDrop: (event) => {},
};

export const draggableProps = {
  onDragStart: (event) => {},
  onDragEnd: (event) => {},
};

// 사용 예시
<Dropzone {...droppableProps} />;
```

**문제점:**

- 프롭을 직접 덮어쓰면 기존 로직이 사라질 수 있음
- 예: `onDragOver`를 덮어쓰면 `event.preventDefault()`가 사라짐

#### 5.7.6 프롭 게터 (Prop Getters)

프롭 컬렉션의 문제를 해결하기 위해 함수 형태로 프롭을 반환하는 패턴입니다.

```javascript
// compose 함수
const compose =
  (...functions) =>
  (...args) =>
    functions.forEach((fn) => fn?.(...args));

// 프롭 게터 구현
export const getDroppableProps = ({
  onDragOver: replacementOnDragOver,
  ...replacementProps
}) => {
  const defaultOnDragOver = (event) => {
    event.preventDefault();
  };

  return {
    onDragOver: compose(replacementOnDragOver, defaultOnDragOver),
    onDrop: (event) => {},
    ...replacementProps,
  };
};

// 사용 예시
<Dropzone
  {...getDroppableProps({
    onDragOver: () => {
      alert("Dragged!");
    },
  })}
/>;
```

**특징:**

- 사용자 정의 프롭을 기본 프롭과 조합
- 기존 로직을 유지하면서 새로운 기능 추가 가능
- `event.preventDefault()`와 `alert("Dragged!")` 모두 실행됨

#### 5.7.7 복합 컴포넌트 (Compound Components)

서로 연결되고 상태를 공유하면서도 독립적으로 렌더링되는 컴포넌트들을 묶는 패턴입니다.

**기본 아코디언 구현:**

```javascript
// 초기 구현 (제한적)
export const Accordion = ({ items }) => {
  const [activeItemIndex, setActiveItemIndex] = useState(0);

  return (
    <ul>
      {items.map((item, index) => (
        <li onClick={() => setActiveItemIndex(index)} key={item.id}>
          <strong>{item.label}</strong>
          {index === activeItemIndex && item.content}
        </li>
      ))}
    </ul>
  );
};
```

**React Context를 사용한 복합 컴포넌트:**

```javascript
// AccordionContext 생성
const AccordionContext = createContext({
  activeItemIndex: 0,
  setActiveItemIndex: () => {},
});

// Accordion 컴포넌트 (Provider)
export const Accordion = ({ children }) => {
  const [activeItemIndex, setActiveItemIndex] = useState(0);

  return (
    <AccordionContext.Provider value={{ activeItemIndex, setActiveItemIndex }}>
      {children}
    </AccordionContext.Provider>
  );
};

// AccordionItem 컴포넌트 (Consumer)
export const AccordionItem = ({ item, index }) => {
  const { activeItemIndex, setActiveItemIndex } = useContext(AccordionContext);

  return (
    <li onClick={() => setActiveItemIndex(index)}>
      <strong>{item.label}</strong>
      {index === activeItemIndex && item.content}
    </li>
  );
};
```

**사용 예시:**

```javascript
// 유연한 렌더링 제어 가능
<Accordion>
  <AccordionItem key={items[0].id} item={items[0]} index={0} />
  <AccordionItem key={items[1].id} item={items[1]} index={1} />
  <hr /> {/* Two와 Three 사이에 가로줄 추가 */}
  <AccordionItem key={items[2].id} item={items[2]} index={2} />
</Accordion>
```

**특징:**

- 자식 컴포넌트가 부모의 상태를 인식하면서도 독립적으로 렌더링
- 부모가 렌더링 제어를 할 수 있어 확장성 향상
- 상태와 관심사 분리를 자연스럽게 도움

#### 5.7.8 상태 리듀서 (State Reducer) 패턴

Kent C. Dodds가 만든 패턴으로, 컴포넌트의 내부 상태 로직을 외부에서 유연하게 제어할 수 있게 합니다.

**기본 토글 컴포넌트:**

```javascript
function toggleReducer(state, action) {
  switch (action.type) {
    case "toggle":
      return !state;
    default:
      return state;
  }
}

function Toggle() {
  const [isOn, setIsOn] = useReducer(toggleReducer, false);

  const handleToggle = () => {
    setIsOn({ type: "toggle" });
  };

  return <button onClick={handleToggle}>{isOn ? "On" : "Off"}</button>;
}
```

**상태 리듀서 패턴 적용:**

```javascript
// stateReducer 프롭을 받는 Toggle 컴포넌트
function Toggle({ stateReducer, ...props }) {
  const [isOn, setIsOn] = useReducer((state, action) => {
    const nextState = toggleReducer(state, action);

    if (stateReducer) {
      return stateReducer(state, { ...action, changes: nextState });
    }

    return nextState;
  }, false);

  const handleToggle = () => {
    setIsOn({ type: "toggle" });
  };

  return <button onClick={handleToggle}>{isOn ? "On" : "Off"}</button>;
}

// 사용 예시 - 수요일에는 토글 비활성화
function App() {
  const customReducer = (state, action) => {
    if (action.type === "toggle" && new Date().getDay() === 3) {
      return state; // 수요일에는 상태 변경 안함
    }
    return action.changes;
  };

  return <Toggle stateReducer={customReducer} />;
}
```

**특징:**

- 컴포넌트 자체를 변경하지 않고 동작을 수정 가능
- 외부 로직이 컴포넌트의 내부 상태 관리와 통합
- 매우 유연하고 재사용 가능한 컴포넌트 생성
- 다양한 동작과 사용 사례를 충족시킬 수 있음
