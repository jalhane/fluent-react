메모이제이션은 이전에 계산된 결과를 캐싱해서 함수의 성능을 최적화하는 기법이다.
즉 같은 입력이면 재사용함 -> 순수해야함

리액트에서 메모는 같은 프랍에 대해 재호출을 하지 않는다는 것
오래 걸리는 계산을 최적화할 수 있음

얕은 비교로 프랍 변경 여부를 파악한다.

참조 타입은 참조, 포인터를 저장한다

- 객체, 배열, 함수

리액트 메모 동작 방식

1. 초기 점검
2. 타입 및 빠른 경로 최적화
3. 개발 모드 확인
4. 새로운 파이버 생성
5. 기존 파이버 업데이트
6. 업데이트 종료
7. 작업용 파이버 업데이트

리액트 메모로 래핑된 컴포넌트를 업데이트 해야하는 혹은 성능 최적화를 위해 건너뛸 수 있는지 판단하는 함수다.
상태, 프랍, 컨텍스트 변경이 없을 경우 프랍이 이전과 동일하면 리렌더링이 일어나지 않는다.

유즈메모

스칼라 값일 경우 메모하는 게 비용이 더 크다.

호스트 컴포넌트는 프랍을 다르게 취급한다.
그래서 이벤트 핸들러에 대한 메모이제이션이 불필요하다.

유즈콜백은

메모로 감싸진 컴포넌트에 불필요하게 렌더링을 유발하는 함수를 넘길 경우 유용하다.

코드 분할 / 지연 로딩

코드 분할은 특정 페이지나 기능에 필요한 자바스크립트를 읽는 법

- 파일을 쪼갬

지연 로딩은 페이지가 완전히 읽어 들여질 때까지 필수적이지 않은 자바스크립트 로딩을 미룸 - 나뉜 코드를 불러옴

| 구분     | 코드 분할 (Code Splitting)                   | 지연 로딩 (Lazy Loading)                       |
| :------- | :------------------------------------------- | :--------------------------------------------- |
| **개념** | 코드를 "나누는" **기술**                     | 나뉜 코드를 "불러오는" **전략**                |
| **목표** | 번들 파일의 크기를 줄이는 것                 | 초기 로딩 시간을 단축하는 것                   |
| **관계** | 지연 로딩을 구현하기 위한 **전제 조건**      | 코드 분할의 가장 대표적인 **활용 사례**        |
| **비유** | 레고를 큰 상자에서 작은 상자들로 나누는 작업 | 필요한 레고 상자만 그때그때 꺼내서 사용하는 것 |

리액트 레이지와 서스펜스를 사용하면 동적으로 컴포넌트를 가져올 수 있다.
모듈 자체가 아닌 프로미스를 반환함, 실제 호출 전까지 파일 호출 및 읽기 x

유즈리듀서를 사용하면 유즈스테이트가 처리할 수 없는 복잡한 상태 변경 로직을 처리할 수 있으며, srp를 지킬 수 있다.
컨테이너/프레젠테이션 패턴은 훅이 나오고 사용되지 않는다.

- https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0

고차 컴포넌트의 경우 컴포넌트에 동작을 주입하는 방식이다. 하지만 이것도 훅으로 다 대체가능하고 훅을 쓰는 게 좋아보인다.
렌더프랍 역시 훅으로 대체됨

제어프랍

```jsx
import { useState } from "react";

const Toggle = ({ checked, onChange, defaultChecked = false }) => {
  // checked 프롭이 있는지 확인 (제어/비제어 모드 구분)
  const isControlled = checked !== undefined;

  // 비제어 모드일 때만 내부 상태 사용
  const [internalChecked, setInternalChecked] = useState(defaultChecked);

  const finalChecked = isControlled ? checked : internalChecked;

  const handleChange = (event) => {
    // 비제어 모드일 경우 내부 상태 업데이트
    if (!isControlled) {
      setInternalChecked(event.target.checked);
    }
    // 프롭으로 받은 onChange 함수가 있으면 호출
    if (onChange) {
      onChange(event);
    }
  };

  return (
    <label>
      <input type="checkbox" checked={finalChecked} onChange={handleChange} />
      {finalChecked ? "On" : "Off"}
    </label>
  );
};

export default Toggle;
```

부모에 의해 제어되는 컴포넌트 패턴
