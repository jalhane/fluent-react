# 1. 리액트는 왜 필요한가요?

웹 기능이 확장되면서, 우수한 UI/UX를 제공하려는 요구 또한 커졌음. 사용자들은 이제 웹이 **'즉각적으로'** 반응하기를 원함.

대규모 애플리케이션에서 **즉각적인 업데이트**를 구현하는 것은 어려웠음.

- DOM을 건드리지 않는 리액트를 사용해도 코드가 복잡하고 디버깅이 어려운 상황이 발생. 하지만 DOM을 직접 건드려 상태를 업데이트 한다? 거기에 애플리케이션 규모가 커진다면 더욱 더 쉽지 않을 것.
- 새 페이지를 읽어드림 ⇒ 리플로우 과정이 반복해서 일어남 ⇒ 성능이슈

# 2 리액트 이전의 세계

이를 해결하기 위해 많은 자바스크립트 혹은 프레임워크가 만들어졌다. 기존 프레임워크들은 자바스크립트의 특정 값이 바뀌면 특정 DOM의 속성이 바뀌도록 연결 해주어 업데이트 하는 작업을 간소화해주는 방식으로 웹개발의 어려움을 해결하였다. 하지만 여전히 문제점은 존재.

- 장황한 보일러플레이트
- 새로운 개념, 문법, 기능으로 인한 러닝커브
- 양방향 데이터 바인딩의 성능 문제

# 3 리액트의 등장

> 이를 해결하기 위해 많은 자바스크립트 혹은 프레임워크가 만들어졌다. 기존 프레임워크들은 자바스크립트의 특정 값이 바뀌면 특정 DOM의 속성이 바뀌도록 연결 해주어 업데이트 하는 작업을 간소화해주는 방식으로 웹개발의 어려움을 해결

리액트는 어떠한 상태가 바뀌었을 때, DOM을 어떻게 업데이트 할 지 정하는 것이 아니라, 아예 다 날려버리고 새로 만들어서 보여준다는 미친 생각을 함.

이렇게 되면 **어떻게 업데이트하지** 에 대한 고민은 하지 않아도 되지만 사용자와의 인터랙션이 자주 발생하고, 동적 UI를 표현해야하는 프로젝트에서는 성능상으로 매우 좋지 않게 될 것임.

하지만 리액트는 Virtual DOM을 사용해서 이를 가능케 했음.

## 3.1 리액트의 핵심 가치

1. 선언적 코드

   - **무엇**을 하고 싶은지 작성하면 리액트가 **어떻게** 알아서 해줌.

   ```jsx
   // 명령형: DOM API로 변형 순서와 방식을 일일이 지시
   const element = document.getElementById("myDiv");
   element.style.backgroundColor = "blue";
   element.style.color = "white";
   element.style.padding = "10px";
   ```

   ```jsx
   // 선언적: 그냥 기술하면 렌더러가 알아서 처리
   <div style={{ backgroundColor: "blue", color: "white", padding: "10px" }}>
     Hello
   </div>
   ```

1. 가상 DOM
   - 실제 DOM 트리를 가볍게 표현한 객체.
   - 가상 DOM을 사용해 컴포넌트의 변경 사항을 추적하고 필요할 때만 컴포넌트를 린더링시킴.
   - 리액트의 핵심. 3장에서 제대로 봐보자.
1. 컴포넌트 모델
   - 한 곳에서 컴포넌트를 정의하고 여러곳에서 재사용할 수 있음.
   - 문제가 발생한 경우 한 곳만 수정해도 관련된 모든 곳이 수정됨.
1. 불변 상태
   - 얕은 비교(참조 비교)를 하는 리액트에서 원본 배열, 객체를 변경하면 리액트는 변경이 일어난 줄 모르고 리렌더링을 건너뛸 수 있음.
   - 새로운 스냅샷(참조)을 생성해서 변경 사항을 추적해야 한다는 의미인데 성능상으로 이슈는 없는 것인가?

## 3.2 플럭스 아키텍처

1. 액션: 새 데이터와 액션의 종류를 식별하는 속성을 포함하는 객체
2. 디스패처: 액션을 받아서 애플리케이션에 등록된 스토어로 보낸다.
3. 스토어: 애플리케이션 상태와 로직을 담당, 스토어 상태가 업데이트 되면 변경 이벤트를 발생시켜 뷰에 변경된 사항을 알려줌
4. 뷰: 스토어에서 변경된 이벤트를 받아 의존하는 데이터 변경되면 업데이트한다.
