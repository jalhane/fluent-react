# 1장. 리액트의 필요성과 등장 배경

## 1.1 리액트는 왜 필요한가요?

리액트는 즉각적인 UI 업데이트와 복잡한 상태 관리 문제를 해결하기 위해 등장했다.
기존 웹은 느린 업데이트와 상태 관리, 보안 문제로 한계가 있었다.
리액트는 효율적인 성능, 일관된 상태 관리, 안전한 코드 작성을 가능하게 한다.

## 1.2 리액트 이전의 세계

전통적인 웹 개발에서는 이벤트 리스너 관리, DOM 조작, 상태 추적 등에서 많은 번거로움과 예측 불가능성이 발생했다.
자바스크립트와 HTML의 상호 의존성, 부작용, 그리고 성능 저하 문제가 코드 확장성과 유지보수를 어렵게 만들었다.
대규모 애플리케이션은 수많은 에지 케이스와 오류 가능성에 직면하며, 효율적이고 안정적인 UI 관리가 필요해졌다.
이런 한계를 극복하기 위해 Backbone, Knockout, AngularJS, jQuery 등 다양한 자바스크립트 기반 솔루션이 등장했다.

### 1.2.1 jQuery

jQuery는 2006년에 등장한 JavaScript 라이브러리로, DOM 조작을 크게 단순화했다.

**jQuery의 특징:**

- 크로스 브라우저 호환성 문제 해결
- 간단한 DOM 선택자와 조작 메서드 제공
- 애니메이션과 이벤트 처리 기능

**jQuery의 한계:**

- 상태 관리의 어려움
- 전역 스코프 오염으로 인한 사이드 이펙트 확산
- 컴포넌트 기반 개발의 부재
- 네이티브 DOM API 의 발전으로 네이티브 성능이 좋아짐

### 1.2.2 Backbone

Backbone은 2010년에 등장한 MVC(Model-View-Controller) 패턴을 적용한 프레임워크다.

**Backbone의 특징:**

- 모델과 뷰의 분리
- 이벤트 기반 통신
- RESTful API와의 연동

**Backbone의 한계:**

- 복잡한 뷰 로직 - 장황한 보일러 플레이트
- 양방향 데이터 바인딩의 부재 - 데이터가 변경되더라도 UI 가 변경되지 않기때문에 다른 플러그인을 써야했다.
- 이벤트 중심 아키텍처 - 이벤트 전파가 전역적으로 이뤄지는데 동시에 파편화되어 관리되고 있어서 이벤트 전파를 막는 작업을 세심하게 작업해야 했다.
- 뷰를 중첩할 수 있는 구조가 어렵게 되어 있다.

### 1.2.3 Knockout

Knockout은 2010년에 등장한 MVVM(Model-View-ViewModel) 패턴의 프레임워크다.

**Knockout의 특징:**

- 양방향 데이터 바인딩
- 옵져버블과 바인딩
  **reactive UI, signal 기반 아키텍처** => 현대 모던 라이브러리에도 잘 쓰인다. ( 공부할 필요 있음 )
- 선언적 UI 업데이트
- 의존성 추적

**Knockout의 한계:**

- 복잡한 컴포넌트 구조에서의 성능 문제
- 학습 곡선의 가파름
- 대규모 팀 개발에서의 일관성 유지 어려움

### 1.2.4 앵귤러JS

앵귤러JS는 2010년에 구글이 개발한 풀스택 프레임워크다.

**앵귤러JS의 특징:** => 좋은 아키텍처 구조

- 양방향 데이터 바인딩
- 모듈식 아키텍처
- 의존성 주입 (DI)

양방향 데이터 바인딩의 한게를 의존성 주입을 통해 해결함.

**앵귤러JS의 한계:**

- 복잡한 학습 곡선
- 성능 문제 (특히 대규모 애플리케이션에서)
- 1 버전 => 2 버전 마이그레이션의 어려움 ( 다른 라이브러리라고 할 정도로 급변함, 1은 유지보수 종료 )
- 타입 안정성 문제
- 혼동되는 &scope 모델
- 과도한 마법(magic)으로 인한 디버깅 어려움 ( 개발도구 제공도 안해줬음 )

## 1.3 리액트 등장

### 1.3.1 리액트의 핵심 가치

리액트는 2013년 페이스북에서 개발한 사용자 인터페이스 라이브러리다.

**핵심 가치:**

1. **선언적 UI**: UI가 어떤 상태인지 명확하게 표현
2. **컴포넌트 기반**: 재사용 가능한 UI 조각들로 구성
3. **불변성** : 순수함수와 불변성을 통해 함수형 프로그래밍의 원칙을 따른다
   - 데이터를 직접 수정하지 않고 새로운 복사본을 생성
   - 원본 데이터의 무결성 보장으로 예측 가능한 상태 관리
   - 메모리 참조 비교를 통한 효율적인 리렌더링 최적화
   - 디버깅과 테스트 시 상태 변화 추적 용이
4. **단방향 데이터 흐름**: 예측 가능한 상태 관리
   - 데이터는 항상 위에서 아래로(부모에서 자식으로) 흐른다
   - 상태 변경은 반드시 상위 컴포넌트에서 이루어진다
   - 자식 컴포넌트는 props를 통해 데이터를 받기만 한다
   - 상태 변화의 원인과 결과를 추적하기 쉽다
   - 복잡한 양방향 바인딩으로 인한 버그 발생 가능성을 제거한다
5. **가상 DOM**: 효율적인 DOM 업데이트

### 1.3.2 리액트 출시

리액트는 2013년 5월 JSConf US에서 처음 공개되었다.

**출시 배경:**

- 페이스북의 복잡한 UI 상태 관리 문제
- 기존 프레임워크들의 한계 인식
- 컴포넌트 기반 아키텍처의 필요성

**초기 반응:**

- 혁신적인 접근 방식으로 주목받음
- JSX 문법에 대한 논란
- 점진적 도입 가능성

### 1.3.3 플럭스 아키텍처

플럭스는 리액트와 함께 제안된 애플리케이션 아키텍처 패턴이다.

**플럭스의 구성 요소:**

1. **Action**: 사용자 상호작용을 나타내는 객체
2. **Dispatcher**: 액션을 스토어에 전달하는 중앙 허브
3. **Store**: 애플리케이션 상태와 비즈니스 로직
4. **View**: 리액트 컴포넌트들

**데이터 흐름:**

```
Action → Dispatcher → Store → View
  ↑                                    |
  └─────────────── 이벤트 ─────────────┘
```

### 1.3.4 플럭스 아키텍처의 장점

**예측 가능성:**

- 단방향 데이터 흐름으로 인한 상태 변화 추적 용이
- 디버깅과 테스트의 단순화

**확장성:**

- 새로운 기능 추가 시 기존 코드 영향 최소화
- 팀 개발에서의 코드 충돌 감소

**유지보수성:**

- 명확한 책임 분리
- 코드의 가독성 향상

순수함수가 Action과 Reducer를 만든다
불변성이 Store의 상태를 보호한다
단방향 데이터 흐름이 View 업데이트를 제어한다
플럭스가 이 모든 것을 체계적으로 관리한다

## 1.4 그래서… 리액트는 왜 필요한가요?

앞서 살펴본 내용을 종합하면, 리액트가 필요한 이유를 명확하게 정리할 수 있다.

### 1.4.1 기존 프레임워크들의 한계 극복

**상태 관리의 단순화:**

- 복잡한 양방향 바인딩 대신 단방향 데이터 흐름
- 예측 가능한 상태 변화로 버그 발생 가능성 감소

**컴포넌트 재사용성:**

- UI 조각을 독립적인 컴포넌트로 분리
- 다른 프로젝트나 팀에서도 재사용 가능

### 1.4.2 개발 생산성 향상

**선언적 UI 작성:**

- 명령형 DOM 조작 대신 상태에 따른 UI 렌더링
- 코드의 가독성과 유지보수성 향상

**개발자 경험 개선:**

- 강력한 개발자 도구와 생태계
- 활발한 커뮤니티와 지속적인 개선

### 1.4.3 성능 최적화

**가상 DOM:**

- 실제 DOM 조작을 최소화하여 성능 향상
- 효율적인 렌더링 알고리즘

**코드 분할과 지연 로딩:**

- 필요한 코드만 로드하여 초기 로딩 시간 단축
- 사용자 경험 향상

### 1.4.4 미래 지향적 아키텍처

**서버 컴포넌트:**

- 서버와 클라이언트의 경계를 넘어선 혁신적 접근
- SEO와 성능의 균형

**동시성 기능:**

- React 18의 동시성 기능으로 더 나은 사용자 경험
- 인터럽트 가능한 렌더링

### 1.4.5 결론

리액트는 단순한 라이브러리가 아니라, 현대 웹 개발의 패러다임을 바꾼 혁신적인 도구다. 기존 프레임워크들이 해결하지 못했던 문제들을 해결하고, 개발자들에게 더 나은 개발 경험을 제공했다.

특히 컴포넌트 기반 아키텍처와 단방향 데이터 흐름은 대규모 애플리케이션 개발에서 필수적인 요소가 되었으며, 지속적인 개선과 혁신으로 웹 개발의 미래를 이끌어가고 있다.

따라서 리액트는 현대 웹 개발자라면 반드시 학습하고 활용해야 할 핵심 기술이라고 할 수 있다.
